%decls %{
  #include <list>
  #include <iostream>
  using namespace std;
  
  #include "Value.h"
  #include "Util.h"
  class Expression;
  class Statement;
  class AssignStatement;
  class VariableDef;
  class MethodDef;
  class ConstantExpression;
  class ParameterDef;
  class BlockStatement;
  class LValueExpression;
  void AddStatement(BlockStatement *block,Statement *stm);
  typedef list<Statement *> StatementList;
  typedef list<Expression *> ExpressionList;
  typedef list<AssignStatement *> AssignList;
  typedef list<VariableDef *> VariableDefList;
  typedef list<MethodDef *> MethodDefList;
  typedef list<ParameterDef *> ParameterDefList;

  typedef enum {OpAdd,OpSub,OpMul,OpDiv,OpMod,OpAnd,OpOr,OpNot,OpGT,OpLT,OpGTE,
  OpLTE,OpEq,OpNotEq,OpRShift,OpLShift,OpRot} ExpressionOperator;
  /* Aqui estan las nuevas listas */
  typedef list<NewStatement *> NewStatementList;
  typedef list<NewExpression *> NewExpressionList;
  typedef list<NewAssignStatement *> NewAssignList;
  typedef list<NewVariableDef *> NewVariableDefList;
  typedef list<NewMethodDef *> NewMethodDefList;
  typedef list<NewParameterDef *> NewParameterDefList;
%}

%{
#include "tree.h"
%}

%option lang="C++"

%node Main %typedef = {
      StatementList *list;
}

%node TheClass %abstract %typedef

%node Expression TheClass %abstract %typedef
%node Statement TheClass %abstract %typedef

%operation %virtual string ToString(TheClass *this)
%operation %virtual TheNewClass ValidarSemantica(TheClass *this)
%operation %virtual void AddStatement([BlockStatement *this],Statement *stm)


%node ClassDef TheClass %typedef = {
    string className;
    VariableDefList *listVariable;
    MethodDefList *listMethod;   
}

%node BinaryExpression Expression %abstract = {
      Expression *FirstExpression;
      Expression *SecondExpression;
}

%node UnaryExpression Expression %abstract = {
      Expression *FirstExpression;
}

%node ConstantExpression Expression %abstract

%node MethodCallExpression Expression = {
    string id;
    ExpressionList *parameters;
}

%node ConstantIntExpression ConstantExpression = {
    int constant;
}

%node ConstantBoolExpression ConstantExpression = {
    bool constant;
}

%node ConstantCharExpression ConstantExpression = {
    char constant;
}

%node ConstantStringExpression ConstantExpression = {
    string constant;
}

%node LValueExpression Expression = {
    string id;
    %nocreate Expression *expr;
}

%node AddExpression BinaryExpression
%node SubExpression BinaryExpression
%node MultExpression BinaryExpression
%node DivExpression BinaryExpression
%node LessThanExpression BinaryExpression
%node LessThanEqualExpression BinaryExpression
%node BigerThanExpression BinaryExpression
%node BigerThanEqualExpression BinaryExpression
%node EqualExpression BinaryExpression
%node NotEqualExpression BinaryExpression
%node ShiftRightExpression BinaryExpression
%node ShiftLeftExpression BinaryExpression
%node RotExpression BinaryExpression
%node OrExpression BinaryExpression
%node AndExpression BinaryExpression
%node NotExpression UnaryExpression
%node ModExpression BinaryExpression

%node ParameterDef Expression = {
    string id;
    Type parameterType;
}

%node VariableDef Statement = {
    string id;
    int first_line;
    int first_column;
    %nocreate Expression *initial_value;
    %nocreate bool isArrayDef;
    %nocreate int array_dimension;
    %nocreate Type variable_type;
}

%node MethodDef Statement = {
    string id;
    %nocreate Statement *block;
    %nocreate ParameterDefList *parameters;
    %nocreate Type returnType;
     
}

%node IfStatement Statement = {
    Expression *condition;
    Statement *statementTrue;
    Statement *statementFalse;
    int first_line;
    int first_column;
}

%node WhileStatement Statement = {
    Expression *condition;
    Statement *statementTrue;
    int first_line;
    int first_column;
}

%node ForStatement Statement = {
    Statement *firstListAssign;
    Expression *condition;
    Statement *lasttListAssign;
    Statement *statementTrue;   
    int first_line;
    int first_column;
}

%node AssignStatement Statement = {
    Expression *leftValue;
    Expression *value;
    int first_line;
    int first_column;
}

%node ReadStatement Statement = {
    ExpressionList *listExpression;
    int first_line;
    int first_column;
}

%node PrintStatement Statement = {
    ExpressionList *listExpression;
    int first_line;
    int first_column;
}

%node MethodCallStatement Statement = {
    string name;
    ExpressionList *parameters;
    int first_line;
    int first_column;
}

%node ReturnStatement Statement = {
    Expression *returnExpression;
    int first_line;
    int first_column;
}

%node BreakStatement Statement = {
    int first_line;
    int first_column;
}

%node ContinueStatement Statement = {
    int first_line;
    int first_column;
}

%node BlockStatement Statement = {
    %nocreate StatementList *listStatements;
    int first_line;
    int first_column;
}

/************** Arbol decorado ****************/

%node TheNewClass %abstract %typedef

%node ClassDef TheNewClass %typedef = {
    string className;
    VariableDefList *listVariable;
    MethodDefList *listMethod;   
}
%node ErrorSemantico %typedef = {
    string msj;
}

ErrorSemantico()
{
    cout << msj;
}

%node NewExpression TheNewClass %abstract %typedef
%node NewStatement TheNewClass %abstract %typedef

/* Aqui comienzan las expresiones decoradas */
%node NewConstantExpression NewExpression %abstract
%node NewConstantIntExpression NewConstantExpression = {
    int Newconstant;
}

%node NewConstantBoolExpression NewConstantExpression = {
    bool Newconstant;
}

%node NewConstantCharExpression NewConstantExpression = {
    char Newconstant;
}

%node NewBinaryExpression NewExpression %abstract = {
    Type type;
    NewExpression *NewFirstExpression;
    NewExpression *NewSecondExpression;
}

%node NewUnaryExpression NewExpression %abstract = {
    Type type;
    NewExpression *NewFirstExpression;
}

%node NewParameterDef NewExpression = {
    string NewId;
    Type NewParameterType;
}

%node NewLValueExpression NewExpression = {
    string NewId;
    %nocreate NewExpression *NewExpr;
}

%node NewMethodCallExpression NewExpression = {
    string NewId;
    NewExpressionList *NewParameters;
}

%node NewAddExpression BinaryExpression
%node NewSubExpression BinaryExpression
%node NewMultExpression BinaryExpression
%node NewDivExpression BinaryExpression
%node NewLessThanExpression BinaryExpression
%node NewLessThanEqualExpression BinaryExpression
%node NewBigerThanExpression BinaryExpression
%node NewBigerThanEqualExpression BinaryExpression
%node NewEqualExpression BinaryExpression
%node NewNotEqualExpression BinaryExpression
%node NewShiftRightExpression BinaryExpression
%node NewShiftLeftExpression BinaryExpression
%node NewRotExpression BinaryExpression
%node NewOrExpression BinaryExpression
%node NewAndExpression BinaryExpression
%node NewNotExpression UnaryExpression
%node NewModExpression BinaryExpression

/* Aqui terminana las expresiones decoradas */

/* Aqui comienzan los statements decorados */
%node NewVariableDef NewStatement = {

}

%node NewMethodDef NewStatement = {
     
}

%node NewIfStatement NewStatement = {
    NewExpression *NewCondition;
    NewStatement *NewStatementTrue;
    NewStatement *NewStatementFalse;
}

%node NewWhileStatement NewStatement = {
    NewExpression *NewCondition;
    NewStatement *NewStatementTrue;
}

%node NewForStatement NewStatement = {
    NewStatement *NewFirstListAssign;
    NewExpression *NewCondition;
    NewStatement *NewLasttListAssign;
    NewStatement *NewStatementTrue;  
}

%node NewAssignStatement NewStatement = {
    NewExpression *NewLeftValue;
    NewExpression *NewValue;
}

%node NewReadStatement NewStatement = {
    NewExpressionList *NewListExpression;
}

%node NewPrintStatement NewStatement = {
    NewExpressionList *NewListExpression;
}

%node NewMethodCallStatement NewStatement = {
    NewExpressionList *NewParameters;
}

%node NewReturnStatement NewStatement = {
    NewExpression *NewReturnExpression;
}

%node NewBreakStatement NewStatement = {

}

%node NewContinueStatement NewStatement = {

}

%node NewBlockStatement NewStatement = {
    %nocreate StatementList *listStatements;
}

/*Aqui termina el arbol decorado*/


AddStatement(BlockStatement)
{
    if(listStatements == 0)
      listStatements = new StatementList();
      
    listStatements->push_back(stm);
}

ToString(MethodCallExpression)
{
    ostringstream out;

    out << this->id << "(" << ListToString(parameters, ", ", false) << ")";

    return out.str();
}
ToString(AddExpression)
{
    ostringstream out;
    out << this->FirstExpression->ToString() << "+" << this->SecondExpression->ToString();
    return out.str();
}
ToString(SubExpression)
{
    ostringstream out;
    out << this->FirstExpression->ToString() << "-" << this->SecondExpression->ToString();
    return out.str();
}
ToString(MultExpression)
{
    ostringstream out;
    out << this->FirstExpression->ToString() << "*" << this->SecondExpression->ToString();
    return out.str();
}
ToString(DivExpression)
{
    ostringstream out;
    out << this->FirstExpression->ToString() << "/" << this->SecondExpression->ToString();
    return out.str();
}
ToString(LessThanExpression)
{
    ostringstream out;
    out << this->FirstExpression->ToString() << "<" << this->SecondExpression->ToString();
    return out.str();
}
ToString(LessThanEqualExpression)
{
    ostringstream out;
    out << this->FirstExpression->ToString() << "<=" << this->SecondExpression->ToString();
    return out.str();
}
ToString(BigerThanExpression)
{
    ostringstream out;
    out << this->FirstExpression->ToString() << ">" << this->SecondExpression->ToString();
    return out.str();
}
ToString(BigerThanEqualExpression)
{
    ostringstream out;
    out << this->FirstExpression->ToString() << ">=" << this->SecondExpression->ToString();
    return out.str();
}
ToString(EqualExpression)
{
    ostringstream out;
    out << this->FirstExpression->ToString() << "==" << this->SecondExpression->ToString();
    return out.str();
}
ToString(NotEqualExpression)
{
    ostringstream out;
    out << this->FirstExpression->ToString() << "!=" << this->SecondExpression->ToString();
    return out.str();
}
ToString(ShiftRightExpression)
{
    ostringstream out;
    out << this->FirstExpression->ToString() << ">>" << this->SecondExpression->ToString();
    return out.str();
}
ToString(ShiftLeftExpression)
{
    ostringstream out;
    out << this->FirstExpression->ToString() << "<<" << this->SecondExpression->ToString();
    return out.str();
}
ToString(RotExpression)
{
    ostringstream out;
    out << this->FirstExpression->ToString() << "rot" << this->SecondExpression->ToString();
    return out.str();
}
ToString(NotExpression)
{
    ostringstream out;
    out <<  "!" << this->FirstExpression->ToString();
    return out.str();
}
ToString(AndExpression)
{
    ostringstream out;
    out << this->FirstExpression->ToString() << "&&" << this->SecondExpression->ToString();
    return out.str();
}
ToString(OrExpression)
{
    ostringstream out;
    out << this->FirstExpression->ToString() << "||" << this->SecondExpression->ToString();
    return out.str();
}
ToString(ModExpression)
{
    ostringstream out;
    out << this->FirstExpression->ToString() << "%" << this->SecondExpression->ToString();
    return out.str();
}
ToString(ConstantIntExpression)
{
    ostringstream out;
    out << this->constant;
    return out.str();
}

ToString(ConstantBoolExpression)
{
    ostringstream out;
    out << this->constant;
    return out.str();
}

ToString(ConstantStringExpression)
{
    ostringstream out;
    out << this->constant;
    return out.str();
}

ToString(ConstantCharExpression)
{
    ostringstream out;
    out << this->constant;
    return out.str();
}

ToString(LValueExpression)
{
    ostringstream out;

    out << this->id;

    if (expr != 0)
	out << "[" << expr->ToString() << "]";

    return out.str();
}

ToString(ParameterDef)
{
    ostringstream out;    
    out << TypeToString(parameterType) << " " << id; 
    return out.str();
}

ToString(MethodDef)
{
    ostringstream out;
    out << TypeToString(returnType) << " " << id << "(";
    if (parameters != 0)
      out << ListToString(parameters, ",", false);
    out << ")" << endl;
    out << block->ToString();
    return out.str();
}

ToString(VariableDef)
{
    ostringstream out;
    out << TypeToString(variable_type) << " " << id;
    if(isArrayDef){
	out << "[" << array_dimension << "]";
    }else if(initial_value != 0){
	out << "=" << initial_value->ToString();
    }
    out << ";";
    return out.str();
}

ToString(ReadStatement)
{
    ostringstream out;
    out << "read ";
    if (listExpression != 0)
	out << ListToString(listExpression, ",", false);
    return out.str();
}

ToString(PrintStatement)
{
    ostringstream out;
    out << "print ";
    if (listExpression != 0)
	out << ListToString(listExpression, ",", false);
    out << ";";
    return out.str();
}

ToString(IfStatement)
{
    ostringstream out;

	out << "if (" << condition->ToString() << ")" << endl;
	out << statementTrue->ToString() << endl;

	if (statementFalse != 0) {
		out << "else" << endl;
		out << statementFalse->ToString() << endl;
	}

    return out.str();
}

ToString(WhileStatement)
{
    ostringstream out;
	out << "while (" << condition->ToString() << ")" << endl;
	out << "{" << statementTrue->ToString() << endl << "}";
    return out.str();
}

ToString(ForStatement)
{
    ostringstream out;
    out << "for(";
    out << firstListAssign->ToString() << ";" << condition->ToString() << ";" << lasttListAssign->ToString() <<")";
    out << statementTrue->ToString();

    return out.str();
}

ToString(AssignStatement)
{
   ostringstream out;
	out << "// Linea " << first_line << " Columna " << first_column << "\n"; 
	out << leftValue->ToString() << " = " << value->ToString() << ";";
   return out.str();
}

ToString(MethodCallStatement)
{
    return this->name + "(" + ListToString(parameters, ", ", false) + ");";
}

ToString(ReturnStatement)
{
    return "return " + returnExpression->ToString() + ";";
}

ToString(BreakStatement)
{
    return "break;";
}

ToString(ContinueStatement)
{
    return "continue;";
}

ToString(BlockStatement)
{
    ostringstream out;

	out << "{" << endl;

	if (listStatements != 0)
		out << ListToString(listStatements, "\n", true);

	out << "}";

    return out.str();
}
ToString(ClassDef)
{
  ostringstream out;
  out << "class " << className << "{" << endl; 
  if (listVariable != 0)
      out << ListToString(listVariable, "\n", true);
  if (listMethod != 0)
      out << ListToString(listMethod, "\n", true);
  out << "}";
  return out.str(); 
}
/*************Validar Semantica ***************/

/* Validar semantica Expresiones */
ValidarSemantica(AddExpression)
{
    NewExpression *first = FirstExpression->ValidarSemantica();
    NewExpression *second = SecondExpression->ValidarSemantica();

    if(first != NULL && second != NULL)
    {
        if((first->type == second->type) /* validar que sea entero*/)
        {
            return new NewAddExpression(NewFirstExpression,NewSecondExpression);
        }
        ErrorSemantico("Error: Tipos Incompatibles");
        return NULL;
    }
    ErrorSemantico("Error: No se pudo Evaluar la Expresion");
    return NULL;
}

ValidarSemantica(SubExpression)
{
    NewExpression *first = FirstExpression->ValidarSemantica();
    NewExpression *second = SecondExpression->ValidarSemantica();

    if(first != NULL && second != NULL)
    {
        if((first->type == second->type) /* validar que sea entero*/)
        {
            return new NewSubExpression(NewFirstExpression,NewSecondExpression);
        }
        ErrorSemantico("Error: Tipos Incompatibles");
        return NULL;
    }
    ErrorSemantico("Error: No se pudo Evaluar la Expresion");
    return NULL;
}

ValidarSemantica(MultExpression)
{
    NewExpression *first = FirstExpression->ValidarSemantica();
    NewExpression *second = SecondExpression->ValidarSemantica();

    if(first != NULL && second != NULL)
    {
        if((first->type == second->type) /* validar que sea entero*/)
        {
            return new NewMultExpression(first,second);
        }
        ErrorSemantico("Error: Tipos Incompatibles");
        return NULL;
    }
    ErrorSemantico("Error: No se pudo Evaluar la Expresion");
    return NULL;
}

ValidarSemantica(DivExpression)
{
    NewExpression *first = FirstExpression->ValidarSemantica();
    NewExpression *second = SecondExpression->ValidarSemantica();

    if(first != NULL && second != NULL)
    {
        if((first->type == second->type) /* validar que sea entero*/)
        {
            return new NewDivExpression(first,second);
        }
        ErrorSemantico("Error: Tipos Incompatibles");
        return NULL;
    }
    ErrorSemantico("Error: No se pudo Evaluar la Expresion");
    return NULL;
}

ValidarSemantica(LessThanExpression)
{
    NewExpression *first = FirstExpression->ValidarSemantica();
    NewExpression *second = SecondExpression->ValidarSemantica();

    if(first != NULL && second != NULL)
    {
        if((first->type == second->type) /* validar que sea entero*/)
        {
            return new NewLessThanExpression(first,second);
        }
        ErrorSemantico("Error: Tipos Incompatibles");
        return NULL;
    }
    ErrorSemantico("Error: No se pudo Evaluar la Expresion");
    return NULL;
}

ValidarSemantica(BigerThanExpression)
{
    NewExpression *first = FirstExpression->ValidarSemantica();
    NewExpression *second = SecondExpression->ValidarSemantica();

    if(first != NULL && second != NULL)
    {
        if((first->type == second->type) /* validar que sea entero*/)
        {
            return new NewBigerThanExpression(first,second);
        }
        ErrorSemantico("Error: Tipos Incompatibles");
        return NULL;
    }
    ErrorSemantico("Error: No se pudo Evaluar la Expresion");
    return NULL;
}

ValidarSemantica(LessThanEqualExpression)
{
    NewExpression *first = FirstExpression->ValidarSemantica();
    NewExpression *second = SecondExpression->ValidarSemantica();

    if(first != NULL && second != NULL)
    {
        if((first->type == second->type) /* validar que sea entero*/)
        {
            return new NewLessThanEqualExpression(first,second);
        }
        ErrorSemantico("Error: Tipos Incompatibles");
        return NULL;
    }
    ErrorSemantico("Error: No se pudo Evaluar la Expresion");
    return NULL;
}

ValidarSemantica(BigerThanEqualExpression)
{
    NewExpression *first = FirstExpression->ValidarSemantica();
    NewExpression *second = SecondExpression->ValidarSemantica();

    if(first != NULL && second != NULL)
    {
        if((first->type == second->type) /* validar que sea entero*/)
        {
            return new NewBigerThanEqualExpression(first,second);
        }
        ErrorSemantico("Error: Tipos Incompatibles");
        return NULL;
    }
    ErrorSemantico("Error: No se pudo Evaluar la Expresion");
    return NULL;
}

ValidarSemantica(EqualExpression)
{
    NewExpression *first = FirstExpression->ValidarSemantica();
    NewExpression *second = SecondExpression->ValidarSemantica();

    if(first != NULL && second != NULL)
    {
        if((first->type == second->type) /* validar que sea entero*/)
        {
            return new NewEqualExpression(first,second);
        }
        ErrorSemantico("Error: Tipos Incompatibles");
        return NULL;
    }
    ErrorSemantico("Error: No se pudo Evaluar la Expresion");
    return NULL;
}

ValidarSemantica(NotEqualExpression)
{
    NewExpression *first = FirstExpression->ValidarSemantica();
    NewExpression *second = SecondExpression->ValidarSemantica();

    if(first != NULL && second != NULL)
    {
        if((first->type == second->type) /* validar que sea entero*/)
        {
            return new NewNotEqualExpression(first,second);
        }
        ErrorSemantico("Error: Tipos Incompatibles");
        return NULL;
    }
    ErrorSemantico("Error: No se pudo Evaluar la Expresion");
    return NULL;
}

ValidarSemantica(ShiftLeftExpression)
{
    NewExpression *first = FirstExpression->ValidarSemantica();
    NewExpression *second = SecondExpression->ValidarSemantica();

    if(first != NULL && second != NULL)
    {
        if((first->type == second->type) /* validar que sea entero*/)
        {
            return new NewShiftLeftExpression(first,second);
        }
        ErrorSemantico("Error: Tipos Incompatibles");
        return NULL;
    }
    ErrorSemantico("Error: No se pudo Evaluar la Expresion");
    return NULL;
}

ValidarSemantica(ShiftRightExpression)
{
    NewExpression *first = FirstExpression->ValidarSemantica();
    NewExpression *second = SecondExpression->ValidarSemantica();

    if(first != NULL && second != NULL)
    {
        if((first->type == second->type) /* validar que sea entero*/)
        {
            return new NewShiftRightExpression(first,second);
        }
        ErrorSemantico("Error: Tipos Incompatibles");
        return NULL;
    }
    ErrorSemantico("Error: No se pudo Evaluar la Expresion");
    return NULL;
}

ValidarSemantica(RotExpression)
{
    NewExpression *first = FirstExpression->ValidarSemantica();
    NewExpression *second = SecondExpression->ValidarSemantica();

    if(first != NULL && second != NULL)
    {
        if((first->type == second->type) /* validar que sea entero*/)
        {
            return new NewRotExpression(first,second);
        }
        ErrorSemantico("Error: Tipos Incompatibles");
        return NULL;
    }
    ErrorSemantico("Error: No se pudo Evaluar la Expresion");
    return NULL;
}

ValidarSemantica(OrExpression)
{
    NewExpression *first = FirstExpression->ValidarSemantica();
    NewExpression *second = SecondExpression->ValidarSemantica();

    if(first != NULL && second != NULL)
    {
        if((first->type == second->type) /* validar que sea entero*/)
        {
            return new NewOrExpression(first,second);
        }
        ErrorSemantico("Error: Tipos Incompatibles");
        return NULL;
    }
    ErrorSemantico("Error: No se pudo Evaluar la Expresion");
    return NULL;
}

ValidarSemantica(AndExpression)
{
    NewExpression *first = FirstExpression->ValidarSemantica();
    NewExpression *second = SecondExpression->ValidarSemantica();

    if(first != NULL && second != NULL)
    {
        if((first->type == second->type) /* validar que sea entero*/)
        {
            return new NewAndExpression(first,second);
        }
        ErrorSemantico("Error: Tipos Incompatibles");
        return NULL;
    }
    ErrorSemantico("Error: No se pudo Evaluar la Expresion");
    return NULL;
}

ValidarSemantica(ModExpression)
{
    NewExpression *first = FirstExpression->ValidarSemantica();
    NewExpression *second = SecondExpression->ValidarSemantica();

    if(first != NULL && second != NULL)
    {
        if((first->type == second->type) /* validar que sea entero*/)
        {
            return new NewModExpression(first,second);
        }
        ErrorSemantico("Error: Tipos Incompatibles");
        return NULL;
    }
    ErrorSemantico("Error: No se pudo Evaluar la Expresion");
    return NULL;
}

ValidarSemantica(NotExpression)
{
    NewExpression *first = NewFirstExpression->ValidarSemantica();
    
    if(first != NULL )
    {
        if(/* validar que sea boleano*/)
        {
            return new NewRotExpression(first);
        }
        ErrorSemantico("Error: Tipo Incompatibles");
        return NULL;
    }
    ErrorSemantico("Error: No se pudo Evaluar la Expresion");
    return NULL;
}

/* Validar semantica Statements */

ValidarSemantica(IfStatement)
{
    NewExpression *newCondition = condition->ValidarSemantica();
    if(newCondition == NULL)
        return NULL;
    if(/*validar tipo*/)
    {
        ErrorSemantico("Error: Condicion if debe se bool");
        return NULL;
    }
    NewExpression *newTrueBlock = statementTrue->ValidarSemantica();
    NewExpression *newFalseBlock;
    if(newTrueBlock == NULL)
        return NULL;
    if(statementFalse != NULL)
    {
        newFalseBlock = statementFalse->ValidarSemantica();
        if(newFalseBlock == NULL)
            return NULL;
    }
    return new NewIfStatement(newCondition,newTrueBlock,newFalseBlock);
}

ValidarSemantica(WhileStatement)
{
    NewStatement *newCondition = condition->ValidarSemantica();
    if(newCondition == NULL)
        return NULL;
    if(/*vaidar tipo*/)
    {
        ErrorSemantico("Error: Condicion if debe se bool");
        return NULL;                       
    }

    NewStatement *newStatementTrue = statementTrue->ValidarSemantica();
    if(newStatementTrue == NULL)
        return NULL;

    return new NewWhileStatement(newCondition,newStatementTrue);
}
ValidarSemantica(ForStatement)
{

}