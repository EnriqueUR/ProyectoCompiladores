%decls %{
  #include <list>
  #include <map>
  #include <string>
  #include <iostream>
  using namespace std;
  
  #include "Value.h"
  #include "Util.h"
  class Expression;
  class Statement;
  class AssignStatement;
  class VariableDef;
  class MethodDef;
  class ConstantExpression;
  class ParameterDef;
  class BlockStatement;
  class Procedimiento;
  class LValueExpression;
  class NewStatement;
  class NewExpression;
  class ClassDef;
  class NewClassDef;

  void AddStatement(BlockStatement *block,Statement *stm);
  typedef list<Statement *> StatementList;
  typedef list<Expression *> ExpressionList;
  typedef list<AssignStatement *> AssignList;
  typedef list<VariableDef *> VariableDefList;
  typedef list<MethodDef *> MethodDefList;
  typedef list<ParameterDef *> ParameterDefList;
  typedef list<string> VariableNameList;

  typedef enum {OpAdd,OpSub,OpMul,OpDiv,OpMod,OpAnd,OpOr,OpNot,OpGT,OpLT,OpGTE,
  OpLTE,OpEq,OpNotEq,OpRShift,OpLShift,OpRot} ExpressionOperator;
  /* Aqui estan las nuevas listas */

  typedef list<NewStatement *> NewStatementList;
  typedef list<NewExpression *> NewExpressionList;

%}

%{

#include "tree.h"

map<string,string> variableStringMap;
list<string> listVariableName;

list<string> arrayList;

list<string> stackCurrentLabelBreak;
list<string> stackCurrentLabelContinue;

list<string> listElseLabel;
list<string> listIfLabel;
list<string> listEndIfLabel;

list<string> listStartWhileLabel;
list<string> listWhileLabel;
list<string> listEndWhileLabel;

list<string> listStartForLabel;
list<string> listForLabel;
list<string> listEndForLabel;
list<string> listContinuePointFor;

list<string> listRegister;
list<string> listRegisterS;

void FreeRegister(string reg)
{
   if(reg != ""){
    listRegister.push_back(reg);
    listRegister.unique();
   }
} 
string getFreeRegister()
{
    int cant = listRegister.size(); 
    if( cant > 0){
        string reg = listRegister.back(); 
        listRegister.pop_back(); 
        return reg;
    }else
        return "NULL";
}
void iniciarRegistros()
{
    for(int i=0;i<8;i++)
    {
      ostringstream reg;
      reg << "$t" << i;
      listRegister.push_front(reg.str());
    }
}

void FreeRegisterS(string reg)
{
   if(reg != ""){
    listRegister.push_back(reg);
    listRegister.unique();
   }
} 
string getFreeRegisterS()
{
    int cant = listRegister.size(); 
    if( cant > 0){
        string reg = listRegister.back(); 
        listRegister.pop_back(); 
        return reg;
    }else
        return "NULL";
}
void iniciarRegistrosS()
{
    for(int i=0;i<4;i++)
    {
      ostringstream reg;
      reg << "$a" << i;
      listRegister.push_front(reg.str());
    }
}

string getFreeLabel(string label)
{
    list<string>::iterator it;
    it = arrayList.begin();
    while(it != arrayList.end())
    {
        if(label == *it)
            return "NULL";
        it++;
    }
    return label;
}

string getLabel(string label){
    if(label == "if")
    {
        ostringstream out;
        int indice = listIfLabel.size();
        out <<"if"<<indice;
        listIfLabel.push_back(out.str());
        return out.str();
    }
    if(label == "else")
    {
        ostringstream out;
        int indice = listElseLabel.size();
        out <<"else"<<indice;
        listElseLabel.push_back(out.str());
        return out.str();
    }
    if(label == "endIf")
    {
        ostringstream out;
        int indice = listEndIfLabel.size();
        out <<"endIf"<<indice;
        listEndIfLabel.push_back(out.str());
        return out.str();
    }
    if(label == "startWhile")
    {
        ostringstream out;
        int indice = listStartWhileLabel.size();
        out <<"startWhile"<<indice;
        listStartWhileLabel.push_back(out.str());
        return out.str();
    }
    if(label == "while")
    {
        ostringstream out;
        int indice = listStartWhileLabel.size();
        out <<"while"<<indice;
        listWhileLabel.push_back(out.str());
        return out.str();
    }
    if(label == "endWhile")
    {
        ostringstream out;
        int indice = listEndWhileLabel.size();
        out <<"endWhile"<<indice;
        listEndWhileLabel.push_back(out.str());
        return out.str();
    }
    if(label == "startFor")
    {
        ostringstream out;
        int indice = listStartForLabel.size();
        out <<"startFor"<<indice;
        listStartForLabel.push_back(out.str());
        return out.str();
    }
    if(label == "for")
    {
        ostringstream out;
        int indice = listForLabel.size();
        out <<"for"<<indice;
        listForLabel.push_back(out.str());
        return out.str();
    }
    if(label == "endFor")
    {
        ostringstream out;
        int indice = listEndForLabel.size();
        out <<"endFor"<<indice;
        listEndForLabel.push_back(out.str());
        return out.str();
    }
    if(label == "continuePoint")
    {
        ostringstream out;
        int indice = listContinuePointFor.size();
        out <<"continuePoint"<<indice;
        listContinuePointFor.push_back(out.str());
        return out.str();
    }
    if(label == "var_str")
    {
        ostringstream out;
        int indice = listVariableName.size();
        out <<"var_str"<<indice;
        listVariableName.push_back(out.str());
        return out.str();
    }
    
    return "";

}

map<string,Procedimiento *> methodDeclared;
map<string,Variable*> variableDeclared; 
int currentOffset = 0;

int currentContexto = 0; 
Contexto *contextos[10];

%}

%option lang="C++"

%node Main %typedef = {
      StatementList *list;
}

%node TheClass %abstract %typedef

%node Expression TheClass %abstract %typedef
%node Statement TheClass %abstract %typedef

%operation %virtual string ToString(TheClass *this)
%operation %virtual TheNewClass *ValidarSemantica(TheClass *this)


%node ClassDef TheClass = {
    string className;
    VariableDefList *listVariable;
    MethodDefList *listMethod;   
}

%node BinaryExpression Expression %abstract = {
      Expression *firstExpression;
      Expression *secondExpression;
}

%node UnaryExpression Expression %abstract = {
      Expression *firstExpression;
}

%node ConstantExpression Expression %abstract

%node MethodCallExpression Expression = {
    string id;
    ExpressionList *parameters;
}

%node ConstantIntExpression ConstantExpression = {
    int constant;
}

%node ConstantBoolExpression ConstantExpression = {
    bool constant;
}

%node ConstantCharExpression ConstantExpression = {
    char constant;
}

%node ConstantStringExpression ConstantExpression = {
    string constant;
}

%node LValueExpression Expression = {
    string id;
    %nocreate Expression *expr = {NULL};
}

%node AddExpression BinaryExpression
%node SubExpression BinaryExpression
%node MultExpression BinaryExpression
%node DivExpression BinaryExpression
%node LessThanExpression BinaryExpression
%node LessThanEqualExpression BinaryExpression
%node BigerThanExpression BinaryExpression
%node BigerThanEqualExpression BinaryExpression
%node EqualExpression BinaryExpression
%node NotEqualExpression BinaryExpression
%node ShiftRightExpression BinaryExpression
%node ShiftLeftExpression BinaryExpression
%node RotExpression BinaryExpression
%node OrExpression BinaryExpression
%node AndExpression BinaryExpression
%node NotExpression UnaryExpression
%node ModExpression BinaryExpression

%node ParameterDef Expression = {
    string id;
    Type parameterType;
}

%node VariableDef Statement = {
    string id;
    int first_line;
    int first_column;
    %nocreate ConstantExpression *initial_value;
    %nocreate bool isArrayDef;
    %nocreate int array_dimension;
    %nocreate Type variable_type;
}

%node LocalVariableDef Statement = {
    int first_line;
    int first_column;
    %nocreate Type variable_type;
    %nocreate VariableNameList *variable_names = {NULL}; 
}

%node MethodDef Statement = {
    string id;
    %nocreate Statement *block;
    %nocreate ParameterDefList *parameters;
    %nocreate Type returnType;
     
}

%node IfStatement Statement = {
    Expression *condition;
    Statement *statementTrue;
    Statement *statementFalse;
    int first_line;
    int first_column;
}

%node WhileStatement Statement = {
    Expression *condition;
    Statement *statementTrue;
    int first_line;
    int first_column;
}

%node ForStatement Statement = {
    Statement *firstListAssign;
    Expression *condition;
    Statement *lastListAssign;
    Statement *statementTrue;   
    int first_line;
    int first_column;
}

%node AssignStatement Statement = {
    Expression *leftValue;
    Expression *value;
    int first_line;
    int first_column;
}

%node ReadStatement Statement = {
    ExpressionList *listExpression;
    int first_line;
    int first_column;
}

%node PrintStatement Statement = {
    ExpressionList *listExpression;
    int first_line;
    int first_column;
}

%node MethodCallStatement Statement = {
    string id;
    ExpressionList *parameters;
    int first_line;
    int first_column;
}

%node ReturnStatement Statement = {
    Expression *returnExpression;
    int first_line;
    int first_column;
}

%node BreakStatement Statement = {
    int first_line;
    int first_column;
}

%node ContinueStatement Statement = {
    int first_line;
    int first_column;
}

%node BlockStatement Statement = {
    %nocreate StatementList *listStatements;
    int first_line;
    int first_column;
}
%operation %virtual void AddStatement([BlockStatement *this],Statement *stm)

/************** Arbol decorado ****************/

%node TheNewClass %abstract %typedef

%node NewClassDef TheNewClass %typedef = {
    string className;
    NewBlockStatement *newBlockStatement;
}

%node NewExpression TheNewClass %abstract %typedef={
  %nocreate string place;
  %nocreate int indice;
  %nocreate Type type;
}
%node NewStatement TheNewClass %abstract %typedef
%operation %virtual string GenerarCodigo(TheNewClass *this)

%node Procedimiento %typedef= {
  string id;
  NewBlockStatement *newBlockStatement;
  %nocreate int countParametros = {0};
}

/* Aqui comienzan las expresiones decoradas */
%node NewConstantExpression NewExpression %abstract
%node NewConstantIntExpression NewConstantExpression = {
    int Newconstant;
}
%node NewConstantStringExpression NewConstantExpression = {
    string Newconstant;
}

%node NewConstantBoolExpression NewConstantExpression = {
    bool Newconstant;
}

%node NewConstantCharExpression NewConstantExpression = {
    char Newconstant;
}

%node NewBinaryExpression NewExpression %abstract = {
    NewExpression *newfirstExpression;
    NewExpression *newSecondExpression;
}

%node NewUnaryExpression NewExpression %abstract = {
    NewExpression *newfirstExpression;
}

%node NewParameterDef NewExpression = {
    string newId;
    Type newParameterType;
}

%node NewLValueExpression NewExpression = {
    string newId;
    NewExpression *newExpr;
    int offset;
    int level;
    %nocreate bool isGlobal = {false};
    %nocreate bool isParameter = {false};
    %nocreate bool isLocal = {false};
}
%operation %virtual string GetDirLValue(NewLValueExpression *this)

%node NewMethodCallExpression NewExpression = {
    string newId;
    NewExpressionList *newParameters;
}

%node NewAddExpression NewBinaryExpression
%node NewSubExpression NewBinaryExpression
%node NewMultExpression NewBinaryExpression
%node NewDivExpression NewBinaryExpression
%node NewLessThanExpression NewBinaryExpression
%node NewLessThanEqualExpression NewBinaryExpression
%node NewBigerThanExpression NewBinaryExpression
%node NewBigerThanEqualExpression NewBinaryExpression
%node NewEqualExpression NewBinaryExpression
%node NewNotEqualExpression NewBinaryExpression
%node NewShiftRightExpression NewBinaryExpression
%node NewShiftLeftExpression NewBinaryExpression
%node NewRotExpression NewBinaryExpression
%node NewOrExpression NewBinaryExpression
%node NewAndExpression NewBinaryExpression
%node NewNotExpression NewUnaryExpression
%node NewModExpression NewBinaryExpression

/* Aqui terminana las expresiones decoradas */

/* Aqui comienzan los statements decorados */

%node NewIfStatement NewStatement = {
    NewExpression *newCondition;
    NewStatement *newStatementTrue;
    NewStatement *newStatementFalse;
}

%node NewWhileStatement NewStatement = {
    NewExpression *newCondition;
    NewStatement *newStatementTrue;
}

%node NewForStatement NewStatement = {
    NewStatement *newFirstListAssign;
    NewExpression *newCondition;
    NewStatement *newLastListAssign;
    NewStatement *newStatementTrue;  
}

%node NewAssignStatement NewStatement = {
    NewExpression *newLeftValue;
    NewExpression *newValue;
}

%node NewReadStatement NewStatement = {
    NewExpressionList *newListExpression;
}

%node NewPrintStatement NewStatement = {
    NewExpressionList *newListExpression;
}

%node NewMethodCallStatement NewStatement = {
  string id;
  NewExpressionList *newParameters;
  %nocreate int indexLevel = {0};
}

%node NewReturnStatement NewStatement = {
    NewExpression *newReturnExpression;
}

%node NewBreakStatement NewStatement = {
}

%node NewContinueStatement NewStatement = {
}

%node NewBlockStatement NewStatement = {
    %nocreate NewStatementList *newListStatements;
}

/*Aqui termina el arbol decorado*/
AddStatement(BlockStatement)
{
    if(listStatements == 0)
      listStatements = new StatementList();
      
    listStatements->push_back(stm);
}

ToString(MethodCallExpression)
{
    ostringstream out;

    out << this->id << "(" << ListToString(parameters, ", ", false) << ")";

    return out.str();
}
ToString(AddExpression)
{
    ostringstream out;
    out << this->firstExpression->ToString() << "+" << this->secondExpression->ToString();
    return out.str();
}
ToString(SubExpression)
{
    ostringstream out;
    out << this->firstExpression->ToString() << "-" << this->secondExpression->ToString();
    return out.str();
}
ToString(MultExpression)
{
    ostringstream out;
    out << this->firstExpression->ToString() << "*" << this->secondExpression->ToString();
    return out.str();
}
ToString(DivExpression)
{
    ostringstream out;
    out << this->firstExpression->ToString() << "/" << this->secondExpression->ToString();
    return out.str();
}
ToString(LessThanExpression)
{
    ostringstream out;
    out << this->firstExpression->ToString() << "<" << this->secondExpression->ToString();
    return out.str();
}
ToString(LessThanEqualExpression)
{
    ostringstream out;
    out << this->firstExpression->ToString() << "<=" << this->secondExpression->ToString();
    return out.str();
}
ToString(BigerThanExpression)
{
    ostringstream out;
    out << this->firstExpression->ToString() << ">" << this->secondExpression->ToString();
    return out.str();
}
ToString(BigerThanEqualExpression)
{
    ostringstream out;
    out << this->firstExpression->ToString() << ">=" << this->secondExpression->ToString();
    return out.str();
}
ToString(EqualExpression)
{
    ostringstream out;
    out << this->firstExpression->ToString() << "==" << this->secondExpression->ToString();
    return out.str();
}
ToString(NotEqualExpression)
{
    ostringstream out;
    out << this->firstExpression->ToString() << "!=" << this->secondExpression->ToString();
    return out.str();
}
ToString(ShiftRightExpression)
{
    ostringstream out;
    out << this->firstExpression->ToString() << ">>" << this->secondExpression->ToString();
    return out.str();
}
ToString(ShiftLeftExpression)
{
    ostringstream out;
    out << this->firstExpression->ToString() << "<<" << this->secondExpression->ToString();
    return out.str();
}
ToString(RotExpression)
{
    ostringstream out;
    out << this->firstExpression->ToString() << "rot" << this->secondExpression->ToString();
    return out.str();
}
ToString(NotExpression)
{
    ostringstream out;
    out <<  "!" << this->firstExpression->ToString();
    return out.str();
}
ToString(AndExpression)
{
    ostringstream out;
    out << this->firstExpression->ToString() << "&&" << this->secondExpression->ToString();
    return out.str();
}
ToString(OrExpression)
{
    ostringstream out;
    out << this->firstExpression->ToString() << "||" << this->secondExpression->ToString();
    return out.str();
}
ToString(ModExpression)
{
    ostringstream out;
    out << this->firstExpression->ToString() << "%" << this->secondExpression->ToString();
    return out.str();
}
ToString(ConstantIntExpression)
{
    ostringstream out;
    out << this->constant;
    return out.str();
}

ToString(ConstantBoolExpression)
{
    ostringstream out;
    out << this->constant;
    return out.str();
}

ToString(ConstantStringExpression)
{
    ostringstream out;
    out << this->constant;
    return out.str();
}

ToString(ConstantCharExpression)
{
    ostringstream out;
    out << this->constant;
    return out.str();
}

ToString(LValueExpression)
{
    ostringstream out;

    out << this->id;

    if (expr != 0)
      out << "[" << expr->ToString() << "]";

    return out.str();
}

ToString(ParameterDef)
{
    ostringstream out;    
    out << TypeToString(parameterType) << " " << id; 
    return out.str();
}

ToString(MethodDef)
{
    ostringstream out;
    out << TypeToString(returnType) << " " << id << "(";
    if (parameters != 0)
      out << ListToString(parameters, ",", false);
    out << ")" << endl;
    out << block->ToString();
    return out.str();
}

ToString(VariableDef)
{
    ostringstream out;
    out << TypeToString(variable_type) << " " << id;
    if(isArrayDef){
      out << "[" << array_dimension << "]";
    }else if(initial_value != 0){
      out << "=" << initial_value->ToString();
    }
    out << ";";
    return out.str();
}
ToString(LocalVariableDef)
{
   return "NADA";
}

ToString(ReadStatement)
{
    ostringstream out;
    out << "read ";
    if (listExpression != 0)
      out << ListToString(listExpression, ",", false);
    return out.str();
}

ToString(PrintStatement)
{
    ostringstream out;
    out << "print ";
    if (listExpression != 0)
      out << ListToString(listExpression, ",", false);
    out << ";";
    return out.str();
}

ToString(IfStatement)
{
    ostringstream out;
    out << "if (" << condition->ToString() << ")" << endl;
    out << statementTrue->ToString() << endl;

    if (statementFalse != 0) {
		  out << "else" << endl;
		  out << statementFalse->ToString() << endl;
    }

    return out.str();
}

ToString(WhileStatement)
{
    ostringstream out;
    out << "while (" << condition->ToString() << ")" << endl;
    out << "{" << statementTrue->ToString() << endl << "}";
    return out.str();
}

ToString(ForStatement)
{
    ostringstream out;
    out << "for(";
    out << firstListAssign->ToString() << ";" << condition->ToString() << ";" << lastListAssign->ToString() <<")";
    out << statementTrue->ToString();

    return out.str();
}

ToString(AssignStatement)
{
    ostringstream out;
    out << "// Linea " << first_line << " Columna " << first_column << "\n"; 
    out << leftValue->ToString() << " = " << value->ToString() << ";";
    return out.str();
}

ToString(MethodCallStatement)
{
    return this->id + "(" + ListToString(parameters, ", ", false) + ");";
}

ToString(ReturnStatement)
{
    return "return " + returnExpression->ToString() + ";";
}

ToString(BreakStatement)
{
    return "break;";
}

ToString(ContinueStatement)
{
    return "continue;";
}

ToString(BlockStatement)
{
    ostringstream out;

    out << "{" << endl;

    if (listStatements != 0)
		  out << ListToString(listStatements, "\n", true);

    out << "}";

    return out.str();
}
ToString(ClassDef)
{
  ostringstream out;
  out << "class " << className << "{" << endl; 
  if (listVariable != 0)
      out << ListToString(listVariable, "\n", true);
  if (listMethod != 0)
      out << ListToString(listMethod, "\n", true);
  out << "}";
  return out.str(); 
}
/*************Validar Semantica ***************/

/* Validar semantica Expresiones */  
ValidarSemantica(ClassDef)
{
    contextos[0] = new Contexto();
    list<VariableDef*>::iterator it1;
    it1 = listVariable->begin();
    while(it1 != listVariable->end())
    {
        (*it1)->ValidarSemantica();
        it1++;
    }

    NewBlockStatement *newBlockStatement = NULL;
    list<MethodDef*>::iterator it2;
    it2 = listMethod->begin();
    while(it2 != listMethod->end())
    {
        (*it2)->ValidarSemantica();
        if((*it2)->id == "main")
            newBlockStatement = (NewBlockStatement*)(*it2)->block->ValidarSemantica();
         else
            (*it2)->block->ValidarSemantica();
        it2++;
    }
    
    return new NewClassDef(className,newBlockStatement);
}

ValidarSemantica(AddExpression)
{
    NewExpression *first = (NewExpression*)firstExpression->ValidarSemantica();
    NewExpression *second = (NewExpression*)secondExpression->ValidarSemantica();

    if(first != NULL && second != NULL)
    {
        if((first->type == second->type) && (first->type == Int))
        {
            NewAddExpression *addExpr = new NewAddExpression(first,second);
            addExpr->type = Int;
            return addExpr;
        }
        ErrorSemantico("Error: Tipos Incompatibles");
        return NULL;
    }
    ErrorSemantico("Error: No se pudo Evaluar la Expresion");
    return NULL;
}

ValidarSemantica(SubExpression)
{
    NewExpression *first = (NewExpression*)firstExpression->ValidarSemantica();
    NewExpression *second = (NewExpression*)secondExpression->ValidarSemantica();

    if(first != NULL && second != NULL)
    {
        if((first->type == second->type) && first->type == Int)
        {
            NewSubExpression *subExpr = new NewSubExpression(first,second);
            subExpr->type = Int;
            return subExpr;
        }
        ErrorSemantico("Error: Tipos Incompatibles");
        return NULL;
    }
    ErrorSemantico("Error: No se pudo Evaluar la Expresion");
    return NULL;
}

ValidarSemantica(MultExpression)
{
    NewExpression *first = (NewExpression*)firstExpression->ValidarSemantica();
    NewExpression *second = (NewExpression*)secondExpression->ValidarSemantica();

    if(first != NULL && second != NULL)
    {
        if((first->type == second->type) && first->type == Int)
        {
            NewMultExpression *multExpr = new NewMultExpression(first,second);
            multExpr->type = Int;
            return multExpr;
        }
        ErrorSemantico("Error: Tipos Incompatibles");
        return NULL;
    }
    ErrorSemantico("Error: No se pudo Evaluar la Expresion");
    return NULL;
}

ValidarSemantica(DivExpression)
{
    NewExpression *first = (NewExpression*)firstExpression->ValidarSemantica();
    NewExpression *second = (NewExpression*)secondExpression->ValidarSemantica();

    if(first != NULL && second != NULL)
    {
        if((first->type == second->type) && first->type == Int)
        {
            NewDivExpression *divExpr = new NewDivExpression(first,second);
            divExpr->type = Int;
            return divExpr;
        }
        ErrorSemantico("Error: Tipos Incompatibles");
        return NULL;
    }
    ErrorSemantico("Error: No se pudo Evaluar la Expresion");
    return NULL;
}

ValidarSemantica(LessThanExpression)
{
    NewExpression *first = (NewExpression*)firstExpression->ValidarSemantica();
    NewExpression *second = (NewExpression*)secondExpression->ValidarSemantica();

    if(first != NULL && second != NULL)
    {
        if((first->type == second->type) && first->type == Int)
        {
            NewLessThanExpression *lessThanExpr = new NewLessThanExpression(first,second); 
            lessThanExpr->type = Boolean;
            return lessThanExpr;
        }
        ErrorSemantico("Error: Tipos Incompatibles");
        return NULL;
    }
    ErrorSemantico("Error: No se pudo Evaluar la Expresion");
    return NULL;
}

ValidarSemantica(BigerThanExpression)
{
    NewExpression *first = (NewExpression*)firstExpression->ValidarSemantica();
    NewExpression *second = (NewExpression*)secondExpression->ValidarSemantica();

    if(first != NULL && second != NULL)
    {
        if((first->type == second->type) && first->type == Int)
        {
            NewBigerThanExpression *bigerThanExpr = new NewBigerThanExpression(first,second);
            bigerThanExpr->type = Boolean;
            return bigerThanExpr;
        }
        ErrorSemantico("Error: Tipos Incompatibles");
        return NULL;
    }
    ErrorSemantico("Error: No se pudo Evaluar la Expresion");
    return NULL;
}

ValidarSemantica(LessThanEqualExpression)
{
    NewExpression *first = (NewExpression*)firstExpression->ValidarSemantica();
    NewExpression *second = (NewExpression*)secondExpression->ValidarSemantica();

    if(first != NULL && second != NULL)
    {
        if((first->type == second->type) && first->type == Int)
        {
            NewLessThanEqualExpression *lessThanEqualExpr = new NewLessThanEqualExpression(first,second);
            lessThanEqualExpr->type = Boolean;
            return lessThanEqualExpr;
        }
        ErrorSemantico("Error: Tipos Incompatibles");
        return NULL;
    }
    ErrorSemantico("Error: No se pudo Evaluar la Expresion");
    return NULL;
}

ValidarSemantica(BigerThanEqualExpression)
{
    NewExpression *first = (NewExpression*)firstExpression->ValidarSemantica();
    NewExpression *second = (NewExpression*)secondExpression->ValidarSemantica();

    if(first != NULL && second != NULL)
    {
        if((first->type == second->type) && first->type == Int)
        {
            NewBigerThanEqualExpression * bigerThanEqualExpr = new NewBigerThanEqualExpression(first,second);
            bigerThanEqualExpr->type = Boolean;
            return bigerThanEqualExpr;
        }
        ErrorSemantico("Error: Tipos Incompatibles");
        return NULL;
    }
    ErrorSemantico("Error: No se pudo Evaluar la Expresion");
    return NULL;
}

ValidarSemantica(EqualExpression)
{
    NewExpression *first = (NewExpression*)firstExpression->ValidarSemantica();
    NewExpression *second = (NewExpression*)secondExpression->ValidarSemantica();

    if(first != NULL && second != NULL)
    {
        if((first->type == second->type) && (first->type == Int || first->type == Boolean))
        {
            NewEqualExpression *equalExpr = new NewEqualExpression(first,second);
            equalExpr->type = Boolean; 
            return equalExpr;
        }
        ErrorSemantico("Error: Tipos Incompatibles");
        return NULL;
    }
    ErrorSemantico("Error: No se pudo Evaluar la Expresion");
    return NULL;
}

ValidarSemantica(NotEqualExpression)
{
    NewExpression *first = (NewExpression*)firstExpression->ValidarSemantica();
    NewExpression *second = (NewExpression*)secondExpression->ValidarSemantica();

    if(first != NULL && second != NULL)
    {
        if((first->type == second->type) && (first->type == Int || first->type == Boolean))
        {
            NewNotEqualExpression *notEqualExpr = new NewNotEqualExpression(first,second);
            notEqualExpr->type = Boolean;
            return notEqualExpr;
        }
        ErrorSemantico("Error: Tipos Incompatibles");
        return NULL;
    }
    ErrorSemantico("Error: No se pudo Evaluar la Expresion");
    return NULL;
}

ValidarSemantica(ShiftLeftExpression)
{
    NewExpression *first = (NewExpression*)firstExpression->ValidarSemantica();
    NewExpression *second = (NewExpression*)secondExpression->ValidarSemantica();

    if(first != NULL && second != NULL)
    {
        if((first->type == second->type) && first->type == Int)
        {
            NewShiftLeftExpression *shiftLeftExpr = new NewShiftLeftExpression(first,second);
            shiftLeftExpr->type = Int;
            return shiftLeftExpr;
        }
        ErrorSemantico("Error: Tipos Incompatibles");
        return NULL;
    }
    ErrorSemantico("Error: No se pudo Evaluar la Expresion");
    return NULL;
}

ValidarSemantica(ShiftRightExpression)
{
    NewExpression *first = (NewExpression*)firstExpression->ValidarSemantica();
    NewExpression *second = (NewExpression*)secondExpression->ValidarSemantica();

    if(first != NULL && second != NULL)
    {
        if((first->type == second->type) && first->type == Int)
        {
            NewShiftRightExpression *shifRightExpr = new NewShiftRightExpression(first,second);
            shifRightExpr->type = Int;
            return shifRightExpr;
        }
        ErrorSemantico("Error: Tipos Incompatibles");
        return NULL;
    }
    ErrorSemantico("Error: No se pudo Evaluar la Expresion");
    return NULL;
}

ValidarSemantica(RotExpression)
{
    NewExpression *first = (NewExpression*)firstExpression->ValidarSemantica();
    NewExpression *second = (NewExpression*)secondExpression->ValidarSemantica();

    if(first != NULL && second != NULL)
    {
        if((first->type == second->type) && first->type == Int)
        {
            NewRotExpression *rotExpr = new NewRotExpression(first,second);
            rotExpr->type = Int;
            return rotExpr;
        }
        ErrorSemantico("Error: Tipos Incompatibles");
        return NULL;
    }
    ErrorSemantico("Error: No se pudo Evaluar la Expresion");
    return NULL;
}

ValidarSemantica(OrExpression)
{
    NewExpression *first = (NewExpression*)firstExpression->ValidarSemantica();
    NewExpression *second = (NewExpression*)secondExpression->ValidarSemantica();

    if(first != NULL && second != NULL)
    {
        if((first->type == second->type) && first->type == Boolean)
        {
            NewOrExpression *orExpr = new NewOrExpression(first,second);
            orExpr->type;
            return orExpr;
        }
        ErrorSemantico("Error: Tipos Incompatibles");
        return NULL;
    }
    ErrorSemantico("Error: No se pudo Evaluar la Expresion");
    return NULL;
}

ValidarSemantica(AndExpression)
{
    NewExpression *first = (NewExpression*)firstExpression->ValidarSemantica();
    NewExpression *second = (NewExpression*)secondExpression->ValidarSemantica();

    if(first != NULL && second != NULL)
    {
        if((first->type == second->type) && first->type == Boolean)
        {
            NewAndExpression *andExpr = new NewAndExpression(first,second);
            andExpr->type = Boolean;
            return andExpr; 
        }
        ErrorSemantico("Error: Tipos Incompatibles");
        return NULL;
    }
    ErrorSemantico("Error: No se pudo Evaluar la Expresion");
    return NULL;
}

ValidarSemantica(ModExpression)
{
    NewExpression *first = (NewExpression*)firstExpression->ValidarSemantica();
    NewExpression *second = (NewExpression*)secondExpression->ValidarSemantica();

    if(first != NULL && second != NULL)
    {
        if((first->type == second->type) && first->type == Int)
        {
            NewModExpression *modExpr = new NewModExpression(first,second);
            modExpr->type = Boolean;
            return modExpr;
        }
        ErrorSemantico("Error: Tipos Incompatibles");
        return NULL;
    }
    ErrorSemantico("Error: No se pudo Evaluar la Expresion");
    return NULL;
}

ValidarSemantica(NotExpression)
{
    NewExpression *first = (NewExpression*)firstExpression->ValidarSemantica();
    
    if(first != NULL )
    {
        if(first->type == Boolean)
        {
            NewNotExpression *notExpr = new NewNotExpression(first);
            notExpr->type = Boolean;
            return notExpr;
        }
        ErrorSemantico("Error: Tipo Incompatibles");
        return NULL;
    }
    ErrorSemantico("Error: No se pudo Evaluar la Expresion");
    return NULL;
}

ValidarSemantica(ParameterDef)
{
    return new NewParameterDef(id,parameterType);
}

ValidarSemantica(MethodCallExpression)
{
    cout << "Entro MethodCallExpression" << endl;
    list<NewExpression*> *newListExpression = new list<NewExpression*>();
    list<Expression*>::iterator it;
    it = parameters->begin();
    while(it != parameters->end())
    {
        NewExpression * newExpr = (NewExpression*)((*it)->ValidarSemantica());
        newListExpression->push_back(newExpr);
        it++;
    }
    cout << "Salio MethodCallExpression" << endl;
    return new NewMethodCallExpression(id,newListExpression);
}

ValidarSemantica(LValueExpression)
{
    cout << "Entro LValueExpression" << endl;
    NewExpression *newExpr = NULL;
    NewLValueExpression *nlv = new NewLValueExpression("",NULL,0,0);
    
    Contexto *con = contextos[0];
    if(con->contextoMap[id] != NULL)
    {
        nlv->isLocal = true;
    }
    else if(variableDeclared[id] != NULL)
    {
        nlv->isGlobal = true;
    }
    else
    {
        nlv->isParameter = true;
    }

    cout << "Salio LValueExpression" << endl;
    int offset = 0;
    int level = 0;
    Contexto *cont = contextos[0];
    map<string,Variable*>::iterator itva;
    itva = cont->contextoMap.begin();
    while(itva != cont->contextoMap.end()) {
      cout << itva->first;
      itva++;
    }
    if(cont->contextoMap[id] == NULL){
        if(variableDeclared[id] ==NULL ){
            ErrorSemantico("variable no definida");
            return NULL;
        }
        else
        {
            offset = variableDeclared[id]->offset;
            level = variableDeclared[id]->level;
        }
    }
    else
    {
        offset = cont->contextoMap[id]->offset;
        level = cont->contextoMap[id]->level;
    }
    nlv->newId = id;
    nlv->newExpr = newExpr;
    nlv->offset = offset;
    nlv->level = level;
    return nlv;
}

ValidarSemantica(ConstantIntExpression)
{
    return new NewConstantIntExpression(constant);
}

ValidarSemantica(ConstantCharExpression)
{
    return new NewConstantCharExpression(constant);
}

ValidarSemantica(ConstantStringExpression)
{
    string id = getLabel("var_str");
    variableStringMap[id] = constant;
    NewConstantStringExpression *tem = new NewConstantStringExpression(id);
    tem->type = String; 
    return tem;
}

ValidarSemantica(ConstantBoolExpression)
{
    return new NewConstantBoolExpression(constant);
}

/* Validar semantica Statements */

ValidarSemantica(IfStatement)
{
    cout <<"Entro IfStatement"<<endl;
    NewExpression *newCondition = (NewExpression*)condition->ValidarSemantica();
    if(newCondition == NULL){
        cout<<"fallo newCondition << IfStatement"<<endl;
        return NULL;
    }
    if(newCondition->type != Boolean)
    {
        ErrorSemantico("Error: Condicion if debe se bool");
        return NULL;
    }
    NewStatement *newTrueBlock = (NewStatement*)statementTrue->ValidarSemantica();
    NewStatement *newFalseBlock;
    if(newTrueBlock == NULL){
        cout<<"fallo newTrueBlock << IfStatement"<<endl;
        return NULL;
    }
    if(statementFalse != NULL)
    {
        newFalseBlock = (NewStatement*)statementFalse->ValidarSemantica();
        if(newFalseBlock == NULL){
            cout<<"fallo newFalseBlock << IfStatement"<<endl;
            return NULL;
        }
    }
    cout <<"Salio IfStatement"<<endl;
    return new NewIfStatement(newCondition,newTrueBlock,newFalseBlock);
}

ValidarSemantica(WhileStatement)
{
    cout <<"Entro WhileStatement"<<endl;
    NewExpression *newCondition = (NewExpression*)condition->ValidarSemantica();
    if(newCondition == NULL){
        cout<<"fallo newCondition << WhileStatement"<<endl;
        return NULL;
    }
    if(newCondition->type != Boolean)
    {
        ErrorSemantico("Error: Condicion if debe se bool");
        return NULL;                       
    }

    NewStatement *newStatementTrue = (NewStatement*)statementTrue->ValidarSemantica();
    if(newStatementTrue == NULL){
        cout<<"fallo newStatementTrue << WhileStatement"<<endl;
        return NULL;
    }
    cout <<"Salio WhileStatement"<<endl;
    return new NewWhileStatement(newCondition,newStatementTrue);
}

ValidarSemantica(ForStatement)
{
    cout <<"Entro ForStatement"<<endl;
    NewStatement *newFirstListAssign = (NewStatement*)firstListAssign->ValidarSemantica();
    if(newFirstListAssign == NULL){
        cout<<"fallo newFirstListAssign << ForStatement"<<endl;
        return NULL;
    }
    NewExpression *newCondition = (NewExpression*)condition->ValidarSemantica();
    if(newCondition == NULL){
        cout<<"fallo newCondition << ForStatement"<<endl;
        return NULL;
    }

    if(newCondition->type != Boolean){
        string str = "La condicion tiene que se bool << ForStatement";
        ErrorSemantico(str);
        return NULL;
    }

    NewStatement *newLastListAssign = (NewStatement*)lastListAssign->ValidarSemantica();
    if(newLastListAssign == NULL){
        cout<<"fallo newLastListAssign << ForStatement"<<endl;
        return NULL;
    }

    NewStatement *newStatementTrue = (NewStatement*)statementTrue->ValidarSemantica();
    if(newStatementTrue == NULL){
        cout<<"fallo newStatementTrue"<<endl;
        return NULL;
    }
    cout <<"Salio ForStatement"<<endl;
    return new NewForStatement(newFirstListAssign,newCondition,newLastListAssign,newStatementTrue);
}

ValidarSemantica(ReturnStatement)
{
    cout <<"Entro ReturnStatement"<<endl;
    NewExpression *newReturnExpression = (NewExpression*)returnExpression->ValidarSemantica();
    if(newReturnExpression == NULL){
        cout<<"fallo newReturnExpression << ReturnStatement"<<endl;
        return NULL;
    }
    cout <<"Salio ReturnStatement"<<endl;
    return new NewReturnStatement(newReturnExpression);
}

ValidarSemantica(BlockStatement)
{
    cout << "Entro BlockStatement" << endl;
    list<NewStatement*> *newListStatement = new list<NewStatement*>();
    if(listStatements == NULL){
        string str = "Error: newListStatement es nulo";
        ErrorSemantico(str);
        return NULL;
    }

    list<Statement*>::iterator it;
    it = listStatements->begin();
    while(it != listStatements->end()){
        Statement *stmTemp = *it;
        NewStatement *newStm ;
        if(dynamic_cast<BlockStatement*>(stmTemp)!= NULL)
        {
            cout<<"entro 1"<<endl;
          currentContexto += 1; 
          contextos[currentContexto] = new Contexto();
          newStm = (NewStatement*)stmTemp->ValidarSemantica();
          contextos[currentContexto] = contextos[currentContexto - 1];
          currentContexto -= 1;
        }
        else
        {
          newStm = (NewStatement*)(stmTemp->ValidarSemantica());
        }
        if(newStm == NULL && dynamic_cast<LocalVariableDef*>(stmTemp) == NULL){
            string str = "Error en el bloque ";
            ErrorSemantico(str);
            return NULL;
        }
        if (dynamic_cast<LocalVariableDef*>(stmTemp)== NULL) {
           newListStatement->push_back(newStm);
        }
        
        it++;
    }
    NewBlockStatement *newblock = new NewBlockStatement(); 
    newblock->newListStatements = newListStatement;
    cout << "Salio BlockStatement" << endl;
    return newblock;
}

ValidarSemantica(ReadStatement)
{
    cout <<"Entro ReadStatement"<<endl;
    list<NewExpression*> *newListExpression = new list<NewExpression*>();
    if(listExpression == NULL)
        return NULL;

    list<Expression*>::iterator it;
    it = listExpression->begin();
    while(it != listExpression->end()) {
        Expression *exprTemp = *it;
        NewExpression *newExpr = (NewExpression*)exprTemp->ValidarSemantica();
        if(newExpr == NULL)
            return NULL;
        newListExpression->push_back(newExpr);
        it++;
    }
    cout <<"Salio ReadStatement"<<endl;
    return new NewReadStatement(newListExpression);
}

ValidarSemantica(PrintStatement)
{
    cout <<"Entro PrintStatement"<<endl;
    list<NewExpression*> *newListExpression = new list<NewExpression*>();
    if(listExpression == NULL)
        return NULL;

    list<Expression*>::iterator it = listExpression->begin();
    while(it != listExpression->end()) {
        Expression *exprTemp = *it;
        NewExpression *newExpr = (NewExpression*)exprTemp->ValidarSemantica();
        if(newExpr == NULL)
            return NULL;
        newListExpression->push_back(newExpr);
        it++;
    }
    cout <<"Salio PrintStatement"<<endl;
    return new NewPrintStatement(newListExpression);
}

ValidarSemantica(AssignStatement)
{
    cout<<"Entro AssignStatement"<<endl;
    NewExpression *newLeftValue = (NewExpression*)leftValue->ValidarSemantica();
    if(newLeftValue == NULL){
        cout<<"fallo newLeftValue << AssignStatement"<<endl;
        return NULL;
    }

    NewExpression *newValue = (NewExpression*)value->ValidarSemantica();
    if(newValue == NULL){
        cout<<"fallo newValue << AssignStatement"<<endl;
        return NULL;
    }
    cout<<"Salio AssignStatement"<<endl;
    return new NewAssignStatement(newLeftValue,newValue);
}

ValidarSemantica(MethodCallStatement)
{
   cout << "Entro MethodCallStatement" << endl;
  list<NewExpression*> *newListExpression = new list<NewExpression*>();
  if(parameters != NULL){
     list<Expression*>::iterator it;
     it = parameters->begin();
     int indice_parametro = 0;
     while(it != parameters->end()){
       NewExpression * newExpr = (NewExpression*)((*it)->ValidarSemantica());
       if(newExpr == NULL)
       {
         string str = "Error << MethodCallStatement";
         ErrorSemantico(str);
         return NULL;
       }
       newExpr->indice = indice_parametro;
       newListExpression->push_back(newExpr);
       it++;  
       indice_parametro++;
     }
   }
  cout<<"Salio MethodCallStatement"<<endl;
  return new NewMethodCallStatement(id,newListExpression);
}

ValidarSemantica(MethodDef)
{
  Contexto *contextoActual = contextos[0];
  currentContexto += 1;

 /* Contexto *contextoNuevo = new Contexto();
  contextoNuevo->currentLevel = 0;
  contextoNuevo->currentOffset = 0;
*/
  list<ParameterDef *>::iterator it;

  if(parameters != NULL){
      it = parameters->begin();
      while(it != parameters->end())
      {
        NewParameterDef *param = (NewParameterDef*)(*it)->ValidarSemantica();
        string str = param->newId;
        Type tipo = param->newParameterType;
        Variable *var = new Variable(contextoActual->currentOffset,contextoActual->currentLevel,0,false,0,true,tipo);
        if(contextoActual->contextoMap[str] != NULL){
          string str = "Parametros repetidos";
          ErrorSemantico(str);
          return NULL;
        }else{
          contextoActual->contextoMap[str] = var;
          contextoActual->currentOffset += 1;
        }
        it++;
      }
  }
  //contextos[currentContexto] = contextoNuevo;
  //contextoNuevo->contextoAnterior = contestoActual;
  if(methodDeclared[id] != NULL)
  {
    string str = "Metodo ya definido << MethodDef ";
    ErrorSemantico(str);
    return NULL;
  }
  Procedimiento *p = new Procedimiento(id,NULL);
  if(parameters != NULL)
    p->countParametros = parameters->size();
  else 
    p->countParametros = 0;

  methodDeclared[id] = p;
  NewBlockStatement *newBlockStatement  = (NewBlockStatement*)(block->ValidarSemantica());
  methodDeclared[id]->newBlockStatement = newBlockStatement;


  return NULL;
}

ValidarSemantica(VariableDef)
{
  cout << "entro "<< endl;
    Variable *var = variableDeclared[id];
    if(var != NULL){
      string error = "Variable ya definida";
      ErrorSemantico(error);
      return NULL;
    }
    Variable *newVariable;
    if(isArrayDef)
    {
        newVariable = new Variable(currentOffset,0,0,true,array_dimension,false,variable_type);
    }
    else
    {
        NewConstantExpression * expr = (NewConstantExpression*)initial_value->ValidarSemantica();
        if(dynamic_cast<NewConstantIntExpression*>(expr) != NULL){
            NewConstantIntExpression *intExpr = (NewConstantIntExpression*)expr;    
            newVariable = new Variable(currentOffset,0,intExpr->Newconstant,false,0,false,Int);
        }
        else
        {
            if(dynamic_cast<NewConstantBoolExpression*>(expr) != NULL){
                NewConstantBoolExpression *boolExpr = (NewConstantBoolExpression*)expr;
                if(boolExpr->Newconstant)
                    newVariable = new Variable(currentOffset,0,1,false,0,false,Boolean);
                else
                    newVariable = new Variable(currentOffset,0,0,false,0,false,Boolean);
            }
        }
    }
    currentOffset+=1;
    variableDeclared[id] = newVariable;
    return NULL;
}
ValidarSemantica(LocalVariableDef)
{
   cout<<"entro <<LocalVariableDef" << endl;
   return NULL;
}

ValidarSemantica(BreakStatement)
{
    return new NewBreakStatement();
}

ValidarSemantica(ContinueStatement)
{
    return new NewContinueStatement();
}

/**************Generacion de Codigo Expresiones **************/
/*    string className;
    NewBlockStatement *newBlockStatement;
*/
GenerarCodigo(NewClassDef)
{
  currentContexto = 0;
  iniciarRegistros();
  ostringstream nuevo;
  Contexto *contextoTemp = contextos[0];
  map<string,Variable*>::iterator it1;
  it1 = variableDeclared.begin();
  nuevo << ".data \n";
  while(it1 != variableDeclared.end())
  {
    Variable *var = it1->second;
    if(var->isArray)
    {
        string label = getFreeLabel((*it1).first);
        if(label == "NULL")
            return "error !!";
        nuevo << label << ": \n";
        nuevo << ".space " << var->dimension * 4 << "\n";
    }
    else
    {
        string label = getFreeLabel((*it1).first);
        if(label == "NULL")
            return "error !!";
        nuevo << label <<": \n";
        if(var->type == Int){
            if(var->value != 0)
                nuevo << ".word " << var->value << " \n";
            else
                nuevo << ".word " << "0 \n";
        }
        else
        {
            if(var->value != 0)
                nuevo << ".word " << "1 \n";
            else
                nuevo << ".word " << "0 \n";
        }
    }
    it1++;
  }
  map<string,string>::iterator mapIt;
  mapIt = variableStringMap.begin();
  while(mapIt != variableStringMap.end()) {
      nuevo << (*mapIt).first << ": \n";
      nuevo << ".asciiz " << (*mapIt).second  << "\n"; 
      mapIt++;
  }
  nuevo << ".text \n";

  nuevo << "main: \n";
  nuevo << newBlockStatement->GenerarCodigo();
  nuevo << "j end"<<endl;
  ostringstream epilogo,prologo;
  
  epilogo << "";
  map<string,Procedimiento*>::iterator it2;
  it2 = methodDeclared.begin();
  while(it2 != methodDeclared.end()) {
      Procedimiento*pro = (*it2).second;
      if(pro->id != "main" ){
        
        nuevo << pro->id << ": \n";
        prologo << "addi $sp, $sp, -32 " << endl;
        for (int i = 0; i < 8; i++) {
            prologo << "sw $s" << i << ", " << (i*4) << "($sp)" << endl;
        }
        prologo << "addi " << "$sp, " << "$sp, " << "-8"<<endl;
        prologo << "sw $ra, 0($sp)"<<endl;
        prologo << "sw $fp, 4($sp)"<<endl; 

        Contexto *con = contextos[0];
        map<string,Variable*>::iterator varIt;
        varIt = con->contextoMap.begin();
        while(varIt != con->contextoMap.end()) {
             Variable *var = varIt->second;
             /*if(var->isParameter)
             {
                prologo << "sw "<< << ", " << var->offset*4 << "($sp)";
             }*/
             varIt++;
         } 
        nuevo << prologo.str();
        nuevo << pro->newBlockStatement->GenerarCodigo();
        
        epilogo << "lw $ra, 0($sp)"<<endl;
        epilogo << "lw $fp, 4($sp)"<<endl;
        epilogo << "addi $sp, $sp, 8"<<endl;
        for (int i = 0; i < 8; i++) {
            epilogo << "lw $s" << i << ", " << (i*4) << "($sp)" << endl;
        }
        epilogo << "addi $sp, $sp, 32" << endl; 
        nuevo << epilogo.str();
        nuevo << "jr $ra"<< endl;
        nuevo << "end:" <<endl;
      }
      it2++;
  }
  

  return nuevo.str();   
}

GenerarCodigo(NewAddExpression)
{
    string L = newfirstExpression->GenerarCodigo();
    string R = newSecondExpression->GenerarCodigo();

    ostringstream nuevo ;
    nuevo << L + R;

    string reg = getFreeRegister();
    nuevo << "add " << reg <<","<<newfirstExpression->place<<","<<newSecondExpression->place << "\n";
    place = reg;
    FreeRegister(newfirstExpression->place);
    FreeRegister(newSecondExpression->place);
    return nuevo.str();
}

GenerarCodigo(NewSubExpression)
{
    string L = newfirstExpression->GenerarCodigo();
    string R = newSecondExpression->GenerarCodigo();

    ostringstream nuevo;
    nuevo << L + R;

    string reg = getFreeRegister();
    nuevo << "sub "<< reg <<","<<newfirstExpression->place<<","<<newSecondExpression->place << "\n";
    place = reg;
    FreeRegister(newfirstExpression->place);
    FreeRegister(newSecondExpression->place);
    return nuevo.str();
}

GenerarCodigo(NewMultExpression) 
{
    string L = newfirstExpression->GenerarCodigo();
    string R = newSecondExpression->GenerarCodigo();

    ostringstream nuevo;
    nuevo << L + R;

    string reg = getFreeRegister();
    nuevo << "mul "<< reg <<", "<<newfirstExpression->place<<", "<<newSecondExpression->place<<"\n";
    place = reg;
    FreeRegister(newfirstExpression->place);
    FreeRegister(newSecondExpression->place);
    return nuevo.str();
}

GenerarCodigo(NewDivExpression)
{
    string L = newfirstExpression->GenerarCodigo();
    string R = newSecondExpression->GenerarCodigo();

    ostringstream nuevo;
    nuevo << L + R;

    string reg = getFreeRegister();
    nuevo << "div "<< reg <<", " <<newfirstExpression->place<<", "<<newSecondExpression->place<< "\n";
    place = reg;
    FreeRegister(newfirstExpression->place);
    FreeRegister(newSecondExpression->place);
    return nuevo.str();
}

GenerarCodigo(NewLessThanExpression)
{
    string L = newfirstExpression->GenerarCodigo();
    string R = newSecondExpression->GenerarCodigo();

    ostringstream nuevo;
    nuevo << L + R;

    string reg = getFreeRegister();
    nuevo << "slt "<< reg << ", "<<newfirstExpression->place<<", "<<newSecondExpression->place << "\n";
    place = reg;
    FreeRegister(newfirstExpression->place);
    FreeRegister(newSecondExpression->place);
    return nuevo.str();   
}

GenerarCodigo(NewLessThanEqualExpression)
{
    string L = newfirstExpression->GenerarCodigo();
    string R = newSecondExpression->GenerarCodigo();

    ostringstream nuevo;
    nuevo << L + R;

    string reg = getFreeRegister();
    nuevo << "sle "<< reg << ", " << newfirstExpression->place<<", "<<newSecondExpression->place <<"\n";
    place = reg;
    FreeRegister(newfirstExpression->place);
    FreeRegister(newSecondExpression->place);
    return nuevo.str();   
}

GenerarCodigo(NewBigerThanExpression)
{
    string L = newfirstExpression->GenerarCodigo();
    string R = newSecondExpression->GenerarCodigo();

    ostringstream nuevo;
    nuevo << L + R;

    string reg = getFreeRegister();
    nuevo << "slt "<< reg << ", " <<newSecondExpression->place<<", "<<newfirstExpression->place <<"\n";
    place = reg;
    FreeRegister(newfirstExpression->place);
    FreeRegister(newSecondExpression->place);
    return nuevo.str();   
}

GenerarCodigo(NewBigerThanEqualExpression)
{
    string L = newfirstExpression->GenerarCodigo();
    string R = newSecondExpression->GenerarCodigo();

    ostringstream nuevo;
    nuevo << L + R;

    string reg = getFreeRegister();
    nuevo << "sle "<< reg << ", "<<newSecondExpression->place<<", "<<newfirstExpression->place <<"\n";
    place = reg;
    FreeRegister(newfirstExpression->place);
    FreeRegister(newSecondExpression->place);
    return nuevo.str();   
}

GenerarCodigo(NewEqualExpression)
{
    string L = newfirstExpression->GenerarCodigo();
    string R = newSecondExpression->GenerarCodigo();

    ostringstream nuevo;
    nuevo << L + R;

    string reg = getFreeRegister();
    nuevo << "seq "<< reg <<", "<<newfirstExpression->place<<", "<<newSecondExpression->place <<"\n";
    place = reg;
    FreeRegister(newfirstExpression->place);
    FreeRegister(newSecondExpression->place);
    return nuevo.str();  
}

GenerarCodigo(NewNotEqualExpression)
{
    string L = newfirstExpression->GenerarCodigo();
    string R = newSecondExpression->GenerarCodigo();

    ostringstream nuevo ;
    nuevo << L + R;

    string reg = getFreeRegister();
    nuevo << "sne "<< reg <<", "<<newfirstExpression->place<<", "<<newSecondExpression->place<<"\n";
    place = reg;
    FreeRegister(newfirstExpression->place);
    FreeRegister(newSecondExpression->place);
    return nuevo.str();
}

GenerarCodigo(NewShiftRightExpression)
{
    string L = newfirstExpression->GenerarCodigo();
    string R = newSecondExpression->GenerarCodigo();

    ostringstream nuevo;
    nuevo << L + R;

    string reg = getFreeRegister();
    nuevo << "srlv "<< reg <<", "<< newfirstExpression->place<<", "<<newSecondExpression->place<<"\n";
    place = reg;
    FreeRegister(newfirstExpression->place);
    FreeRegister(newSecondExpression->place);
    return nuevo.str();
}

GenerarCodigo(NewShiftLeftExpression)
{
    string L = newfirstExpression->GenerarCodigo();
    string R = newSecondExpression->GenerarCodigo();

    ostringstream nuevo;
    nuevo << L + R;

    string reg = getFreeRegister();
    nuevo << "sllv "<< reg <<", "<< newfirstExpression->place<<", "<<newSecondExpression->place << "\n";
    place = reg;
    FreeRegister(newfirstExpression->place);
    FreeRegister(newSecondExpression->place);
    return nuevo.str();
}

GenerarCodigo(NewRotExpression)
{
    string L = newfirstExpression->GenerarCodigo();
    string R = newSecondExpression->GenerarCodigo();

    ostringstream nuevo;
    nuevo << L + R;

    string reg = getFreeRegister();
    nuevo << "ror "<< reg <<", "<< newfirstExpression->place<<", "<<newSecondExpression->place<<"\n";
    place = reg;
    FreeRegister(newfirstExpression->place);
    FreeRegister(newSecondExpression->place);
    return nuevo.str();
}

GenerarCodigo(NewOrExpression)
{
    string L = newfirstExpression->GenerarCodigo();
    string R = newSecondExpression->GenerarCodigo();

    ostringstream nuevo;
    nuevo << L + R;
    //FreeRegister(newfirstExpression->place);
    //FreeRegister(newSecondExpression->place);
    string reg = "";//= getFreeRegister();
    nuevo << "or "<< reg <<", "<< newfirstExpression->place<<", "<<newSecondExpression->place<<"\n";
    place = reg;

    return nuevo.str();
}

GenerarCodigo(NewAndExpression)
{
    string L = newfirstExpression->GenerarCodigo();
    string R = newSecondExpression->GenerarCodigo();

    ostringstream nuevo;
    nuevo << L + R;
    //FreeRegister(newfirstExpression->place);
    //FreeRegister(newSecondExpression->place);
    string registro = "";// = getFreeRegister();
    nuevo << "and "<< registro << newfirstExpression->place<<","<<newSecondExpression->place <<"\n";
    place = registro;

    return nuevo.str();
}

GenerarCodigo(NewNotExpression)
{
    string L = newfirstExpression->GenerarCodigo();

    ostringstream nuevo;
    nuevo << L ;
    
    string reg = getFreeRegister();
    nuevo << "seq " << reg <<", "<<"$zero, "<< newfirstExpression->place << "\n";
    place = reg;

    FreeRegister(newfirstExpression->place);
    return nuevo.str();
}

GenerarCodigo(NewModExpression)
{
    string L = newfirstExpression->GenerarCodigo();
    string R = newSecondExpression->GenerarCodigo();

    ostringstream nuevo;
    nuevo << L + R;

    string reg = getFreeRegister();
    nuevo << "rem "<<reg<<", "<< newfirstExpression->place<<", "<<newSecondExpression->place<<"\n";
    place = reg;

    FreeRegister(newfirstExpression->place);
    FreeRegister(newSecondExpression->place);
    return nuevo.str();
}

/************** Generacion de Codigo Sentencias **************/

GenerarCodigo(NewIfStatement)
{
    string labelIf = getLabel("if");
    string labelElse = getLabel("else");
    string labelEndIf = getLabel("endIf");

    bool elseStatement = (newStatementFalse != NULL); 
    string condition = newCondition->GenerarCodigo();
    string newTrueBlock = newStatementTrue->GenerarCodigo();
    string newFalseBlock;
    if(elseStatement)
        newFalseBlock = newStatementFalse->GenerarCodigo();
    
    ostringstream nuevo;
    nuevo << condition << "\n";
    if(elseStatement)
        nuevo << "beq " << newCondition->place <<", "<< "$zero, " << labelElse << "\n";
    else 
        nuevo << "beq " << newCondition->place <<", "<< "$zero, " << labelEndIf << "\n";
    nuevo << newTrueBlock << "\n";
    if(elseStatement){
        nuevo <<"j "<< labelEndIf << endl;
        nuevo << labelElse << ": \n";
        nuevo << newFalseBlock  << "\n";
    }
    nuevo << labelEndIf << ": \n";

    return nuevo.str();
}

GenerarCodigo(NewWhileStatement)
{
    cout << "entro << NewWhileStatement"<<endl;
    string labelStartWhile = getLabel("startWhile");
    string labelWhile = getLabel("while");
    string labelEndWhile = getLabel("endWhile");
    stackCurrentLabelBreak.push_back(labelEndWhile);
    stackCurrentLabelContinue.push_back(labelStartWhile);

    string condition = newCondition->GenerarCodigo();
    string stmTrue = newStatementTrue->GenerarCodigo();
    
    ostringstream nuevo;
    nuevo << labelStartWhile << ": \n";
    nuevo << condition;
    nuevo << "beq " << newCondition->place <<", "<< "$zero, " << labelEndWhile << "\n";
    nuevo << stmTrue;
    nuevo << "j "<< labelStartWhile << "\n";
    nuevo << labelEndWhile << ": \n";

    stackCurrentLabelContinue.pop_back();
    stackCurrentLabelBreak.pop_back();
    FreeRegister(newCondition->place);

    return nuevo.str();
}

GenerarCodigo(NewForStatement)
{

    string labelStartFor = getLabel("startFor");
    string labelfor = getLabel("for");
    string labelEndfor = getLabel("endFor");
    string continuePoint = getLabel("continuePoint");

    stackCurrentLabelBreak.push_back(labelEndfor);
    stackCurrentLabelContinue.push_back(continuePoint);

    string firstListAssign = newFirstListAssign->GenerarCodigo();
    string lastListAssign = newLastListAssign->GenerarCodigo();
    string condition = newCondition->GenerarCodigo();
    string newTrueBlock = newStatementTrue->GenerarCodigo();
    ostringstream nuevo;

    nuevo << firstListAssign;
    nuevo << labelStartFor << ": \n";
    nuevo << condition;
    nuevo << "beq " << newCondition->place <<", " << "$zero, " << labelEndfor << "\n";
    nuevo << newTrueBlock;
    nuevo << continuePoint << ": \n"; 
    nuevo << lastListAssign;
    nuevo << "j " << labelStartFor << "\n"; 
    nuevo << labelEndfor << ": \n";

    stackCurrentLabelContinue.pop_back();
    stackCurrentLabelBreak.pop_back();
    FreeRegister(newCondition->place);

    return nuevo.str();
}

GenerarCodigo(NewAssignStatement)
{
    ostringstream nuevo;
    string leftValue = ((NewLValueExpression*)newLeftValue)->GetDirLValue();
    string value = newValue->GenerarCodigo();

    nuevo << leftValue;
    nuevo << value;
    nuevo << "sw "<< newValue->place <<", 0("<< newLeftValue->place << ")\n";

    FreeRegister(newLeftValue->place);
    FreeRegister(newValue->place);
    return nuevo.str();
}

GenerarCodigo(NewMethodCallStatement)
{
   cout << "entro <<NewMethodCallStatement"<<endl;
    ostringstream nuevo;
    if(newParameters != NULL){
       list<NewExpression *>::iterator it;
       it = newParameters->begin();
       int parameterCount = newParameters->size();
       nuevo << "addi " << "$sp, $sp, " << (-1 * (parameterCount*4)) << "\n";
       while(it != newParameters->end())
       {   
           NewExpression * newExpr = *it;
           nuevo << newExpr->GenerarCodigo(); 
           string reg = getFreeRegister();
           nuevo << "sw " << newExpr->place << ", "<<(newExpr->indice * 4)<<"($sp)"<< "\n";
           FreeRegister(reg);
           it++;
       }
     }
     cout << "salio <<NewMethodCallStatement"<<endl;
    nuevo << "jal " << id << "\n";
    return nuevo.str();
}

GenerarCodigo(NewReturnStatement)
{
    ostringstream nuevo;
    nuevo << newReturnExpression->GenerarCodigo();
    nuevo << "move "<< "$v0" <<" , "<< newReturnExpression->place << "\n"; 
    nuevo << "jr " << "$ra" << "\n";
    return nuevo.str();
}

GenerarCodigo(NewPrintStatement)
{
    ostringstream nuevo;
    list<NewExpression *>::iterator it;
    it = newListExpression->begin();
    while(it != newListExpression->end())
    { 
        NewExpression *expr = *it;
        nuevo << expr->GenerarCodigo();
        if(expr->type == Int)
        {
            nuevo << "li " << "$v0" <<", "<< "1 \n";
            nuevo << "move " << "$a0"<<", " << expr->place << "\n";
            nuevo << "syscall \n";
        }
        else if(expr->type == String)
        {
            nuevo << "li " << "$v0" <<", "<< "4 \n";
            nuevo << "move " << "$a0" <<", "<< expr->place <<"\n";
            nuevo << "syscall \n";
        }

        FreeRegister(expr->place);
        it++;
    }

    return nuevo.str();
}

GenerarCodigo(NewReadStatement)
{
    ostringstream nuevo;
    list<NewExpression *>::iterator it;
    it = newListExpression->begin();
    while(it != newListExpression->end())
    { 
        NewExpression *expr = (*it);
        nuevo << expr->GenerarCodigo();
        it++;
    }

    return nuevo.str();
}

GenerarCodigo(NewConstantIntExpression)
{
   ostringstream nuevo;
   
   string reg = getFreeRegister();
   nuevo << "li " << reg <<", "<< Newconstant << "\n";
   place = reg;

   return nuevo.str();
}

GenerarCodigo(NewConstantBoolExpression)
{
   ostringstream nuevo;
   
   string reg = getFreeRegister();
   if(Newconstant)
      nuevo << "li " << reg <<", 1"<<"\n";
   else
      nuevo << "li " << reg <<", 0"<<"\n";
   place = reg;

   return nuevo.str();
}

GenerarCodigo(NewConstantStringExpression)
{
    ostringstream nuevo;
    string reg = getFreeRegister();
    nuevo << "la "<< reg <<", "<< Newconstant << "\n"; 
    place = reg;
    return nuevo.str();
}

GenerarCodigo(NewLValueExpression)
{
    ostringstream nuevo;

    string regS = getFreeRegisterS();
    Contexto *context = contextos[0];

   // if (isGlobal) 
   // {    
        nuevo << "la " << regS << ", " << newId << endl;
        if (newExpr != NULL) {
            nuevo << newExpr->GenerarCodigo();
            nuevo << "sll " << newExpr->place << ", " << newExpr->place << ", 2" << endl;
            nuevo << "add " << regS << ", " << regS << ", "<< newExpr->place << endl;
        }
        
   /* }
     else if (isParameter) {
        nuevo << "addi " << regS << ", $fp, " << (offset*4)*-1 << endl;
    }
     else 
    {
        nuevo << "la " << regS << ", display" << endl;
        nuevo << "addi " << regS << ", " << regS << ", " << (level*4) << endl;
        nuevo << "lw " << regS << ", 0(" << regS << ")" << endl;
        nuevo << "addi " << regS << ", " << regS << ", " << (offset * 4)+4 << endl;
      }*/
    nuevo <<"lw " << regS << ", 0(" << regS << ")" << endl;
    this->place = regS;

    return nuevo.str();
}

GenerarCodigo(NewMethodCallExpression)
{
   ostringstream nuevo;
    if(newParameters != NULL){
       list<NewExpression *>::iterator it;
       it = newParameters->begin();
       int parameterCount = newParameters->size();
       nuevo << "addi " << "$sp, $sp, " << (-1 * (parameterCount*4)) << "\n";
       while(it != newParameters->end())
       {   
           NewExpression * newExpr = *it; 
           string reg = getFreeRegister();
           nuevo << "sw " << (newExpr->indice * 4)<<"($sp)" << "\n";
           FreeRegister(reg);
           it++;
       }
     }
     place = "$v0";
    return nuevo.str();
}

GenerarCodigo(NewBreakStatement)
{
   ostringstream nuevo;
   string label = stackCurrentLabelBreak.back();
   nuevo << "j "<< label<< "\n";
   return nuevo.str();
}

GenerarCodigo(NewContinueStatement)
{
   ostringstream nuevo;
   string label = stackCurrentLabelContinue.back();
   nuevo << "j "<< label<< "\n";
   return nuevo.str();  
}

GenerarCodigo(NewBlockStatement)
{
   cout << "entro <<NewBlockStatement"<<endl;
    ostringstream nuevo;
    list<NewStatement*>::iterator it;
    it = newListStatements->begin();
    while(it != newListStatements->end()) {
        NewStatement *stm = (*it);
        nuevo << stm->GenerarCodigo();
        it++;
    }
    cout << "salio <<NewBlockStatement"<<endl;
    return nuevo.str();
}


GenerarCodigo(NewConstantCharExpression){return "NADA \n";}

GenerarCodigo(NewParameterDef){return "NADA \n";}

/********************OTROS MOPERATION************************/
GetDirLValue(NewLValueExpression)
{
 ostringstream nuevo;

    string regS = getFreeRegisterS();
    Contexto *context = contextos[0];

    //if (isGlobal) 
    //{    
        nuevo << "la " << regS << ", " << newId << endl;
        if (newExpr != NULL) {
            nuevo << newExpr->GenerarCodigo();
            nuevo << "sll " << newExpr->place << ", " << newExpr->place << ", 2" << endl;
            nuevo << "add " << regS << ", " << regS << ", "<< newExpr->place << endl;
        }
        
    /*}
     else if (isParameter) {
        nuevo << "addi " << regS << ", $fp, " << (offset*4)*-1 << endl;
    }
     else 
    {
        nuevo << "la " << regS << ", display" << endl;
        nuevo << "addi " << regS << ", " << regS << ", " << (level*4) << endl;
        nuevo << "lw " << regS << ", 0(" << regS << ")" << endl;
        nuevo << "addi " << regS << ", " << regS << ", " << (offset * 4)+4 << endl;
      }*/
    this->place = regS;

    return nuevo.str();
}