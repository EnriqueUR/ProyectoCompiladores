%decls %{
  #include <list>
  #include <map>
  #include <iostream>
  using namespace std;
  
  #include "Value.h"
  #include "Util.h"
  class Expression;
  class Statement;
  class AssignStatement;
  class VariableDef;
  class MethodDef;
  class ConstantExpression;
  class ParameterDef;
  class BlockStatement;
  class Procedimiento;
  class LValueExpression;
  class NewStatement;
  class NewExpression;
  class ClassDef;
  class NewClassDef;

  void AddStatement(BlockStatement *block,Statement *stm);
  typedef list<Statement *> StatementList;
  typedef list<Expression *> ExpressionList;
  typedef list<AssignStatement *> AssignList;
  typedef list<VariableDef *> VariableDefList;
  typedef list<MethodDef *> MethodDefList;
  typedef list<ParameterDef *> ParameterDefList;

  typedef enum {OpAdd,OpSub,OpMul,OpDiv,OpMod,OpAnd,OpOr,OpNot,OpGT,OpLT,OpGTE,
  OpLTE,OpEq,OpNotEq,OpRShift,OpLShift,OpRot} ExpressionOperator;
  /* Aqui estan las nuevas listas */

  typedef list<NewStatement *> NewStatementList;
  typedef list<NewExpression *> NewExpressionList;

%}

%{
#include "tree.h"
void FreeRegister(string register)
{
    /* hacer algo */
} 
string getFreeRegister(){return " ";}

string getLabel(string label){return "";}

map<string,Procedimiento *> methodDeclared;
list<string> stackCurrentLabel;
list<string> listElseLabel;
list<string> listIfLabel;
list<string> listEndIfLabel;
list<string> listWhileLabel;
list<string> listEndWhileLabel;
list<string> listForLabel;
list<string> listEndForLabel;

int currentContexto = 0; 
Contexto *contextos[10];
%}

%option lang="C++"

%node Main %typedef = {
      StatementList *list;
}

%node TheClass %abstract %typedef

%node Expression TheClass %abstract %typedef
%node Statement TheClass %abstract %typedef

%operation %virtual string ToString(TheClass *this)
%operation %virtual TheNewClass *ValidarSemantica(TheClass *this)


%node ClassDef TheClass = {
    string className;
    VariableDefList *listVariable;
    MethodDefList *listMethod;   
}

%node BinaryExpression Expression %abstract = {
      Expression *firstExpression;
      Expression *secondExpression;
}

%node UnaryExpression Expression %abstract = {
      Expression *firstExpression;
}

%node ConstantExpression Expression %abstract

%node MethodCallExpression Expression = {
    string id;
    ExpressionList *parameters;
}

%node ConstantIntExpression ConstantExpression = {
    int constant;
}

%node ConstantBoolExpression ConstantExpression = {
    bool constant;
}

%node ConstantCharExpression ConstantExpression = {
    char constant;
}

%node ConstantStringExpression ConstantExpression = {
    string constant;
}

%node LValueExpression Expression = {
    string id;
    %nocreate Expression *expr;
}

%node AddExpression BinaryExpression
%node SubExpression BinaryExpression
%node MultExpression BinaryExpression
%node DivExpression BinaryExpression
%node LessThanExpression BinaryExpression
%node LessThanEqualExpression BinaryExpression
%node BigerThanExpression BinaryExpression
%node BigerThanEqualExpression BinaryExpression
%node EqualExpression BinaryExpression
%node NotEqualExpression BinaryExpression
%node ShiftRightExpression BinaryExpression
%node ShiftLeftExpression BinaryExpression
%node RotExpression BinaryExpression
%node OrExpression BinaryExpression
%node AndExpression BinaryExpression
%node NotExpression UnaryExpression
%node ModExpression BinaryExpression

%node ParameterDef Expression = {
    string id;
    Type parameterType;
}

%node VariableDef Statement = {
    string id;
    int first_line;
    int first_column;
    %nocreate Expression *initial_value;
    %nocreate bool isArrayDef;
    %nocreate int array_dimension;
    %nocreate Type variable_type;
}

%node MethodDef Statement = {
    string id;
    %nocreate Statement *block;
    %nocreate ParameterDefList *parameters;
    %nocreate Type returnType;
     
}

%node IfStatement Statement = {
    Expression *condition;
    Statement *statementTrue;
    Statement *statementFalse;
    int first_line;
    int first_column;
}

%node WhileStatement Statement = {
    Expression *condition;
    Statement *statementTrue;
    int first_line;
    int first_column;
}

%node ForStatement Statement = {
    Statement *firstListAssign;
    Expression *condition;
    Statement *lastListAssign;
    Statement *statementTrue;   
    int first_line;
    int first_column;
}

%node AssignStatement Statement = {
    Expression *leftValue;
    Expression *value;
    int first_line;
    int first_column;
}

%node ReadStatement Statement = {
    ExpressionList *listExpression;
    int first_line;
    int first_column;
}

%node PrintStatement Statement = {
    ExpressionList *listExpression;
    int first_line;
    int first_column;
}

%node MethodCallStatement Statement = {
    string id;
    ExpressionList *parameters;
    int first_line;
    int first_column;
}

%node ReturnStatement Statement = {
    Expression *returnExpression;
    int first_line;
    int first_column;
}

%node BreakStatement Statement = {
    int first_line;
    int first_column;
}

%node ContinueStatement Statement = {
    int first_line;
    int first_column;
}

%node BlockStatement Statement = {
    %nocreate StatementList *listStatements;
    int first_line;
    int first_column;
}
%operation %virtual void AddStatement([BlockStatement *this],Statement *stm)

/************** Arbol decorado ****************/

%node TheNewClass %abstract %typedef

%node NewClassDef TheNewClass %typedef = {
    string className;
    NewBlockStatement *newBlockStatement;
}

%node NewExpression TheNewClass %abstract %typedef={
  %nocreate string place;
  %nocreate Type type;
}
%node NewStatement TheNewClass %abstract %typedef
%operation %virtual string GenerarCodigo(TheNewClass *this)

%node Procedimiento %typedef= {
  string id;
  NewBlockStatement *newBlockStatement;
}

/* Aqui comienzan las expresiones decoradas */
%node NewConstantExpression NewExpression %abstract
%node NewConstantIntExpression NewConstantExpression = {
    int Newconstant;
}
%node NewConstantStringExpression NewConstantExpression = {
    string Newconstant;
}

%node NewConstantBoolExpression NewConstantExpression = {
    bool Newconstant;
}

%node NewConstantCharExpression NewConstantExpression = {
    char Newconstant;
}

%node NewBinaryExpression NewExpression %abstract = {
    NewExpression *newfirstExpression;
    NewExpression *newSecondExpression;
}

%node NewUnaryExpression NewExpression %abstract = {
    NewExpression *newfirstExpression;
}

%node NewParameterDef NewExpression = {
    string newId;
    Type newParameterType;
}

%node NewLValueExpression NewExpression = {
    string newId;
    %nocreate NewExpression *newExpr;

    int offset;
    int level;
}

%node NewMethodCallExpression NewExpression = {
    string newId;
    NewExpressionList *newParameters;
}

%node NewAddExpression NewBinaryExpression
%node NewSubExpression NewBinaryExpression
%node NewMultExpression NewBinaryExpression
%node NewDivExpression NewBinaryExpression
%node NewLessThanExpression NewBinaryExpression
%node NewLessThanEqualExpression NewBinaryExpression
%node NewBigerThanExpression NewBinaryExpression
%node NewBigerThanEqualExpression NewBinaryExpression
%node NewEqualExpression NewBinaryExpression
%node NewNotEqualExpression NewBinaryExpression
%node NewShiftRightExpression NewBinaryExpression
%node NewShiftLeftExpression NewBinaryExpression
%node NewRotExpression NewBinaryExpression
%node NewOrExpression NewBinaryExpression
%node NewAndExpression NewBinaryExpression
%node NewNotExpression NewUnaryExpression
%node NewModExpression NewBinaryExpression

/* Aqui terminana las expresiones decoradas */

/* Aqui comienzan los statements decorados */

%node NewIfStatement NewStatement = {
    NewExpression *newCondition;
    NewStatement *newStatementTrue;
    NewStatement *newStatementFalse;
}

%node NewWhileStatement NewStatement = {
    NewExpression *newCondition;
    NewStatement *newStatementTrue;
}

%node NewForStatement NewStatement = {
    NewStatement *newFirstListAssign;
    NewExpression *newCondition;
    NewStatement *newLastListAssign;
    NewStatement *newStatementTrue;  
}


%node NewAssignStatement NewStatement = {
    NewExpression *newLeftValue;
    NewExpression *newValue;
}

%node NewReadStatement NewStatement = {
    NewExpressionList *newListExpression;
}

%node NewPrintStatement NewStatement = {
    NewExpressionList *newListExpression;
}

%node NewMethodCallStatement NewStatement = {
  string id;
  NewExpressionList *newParameters;
}

%node NewReturnStatement NewStatement = {
    NewExpression *newReturnExpression;
}

%node NewBreakStatement NewStatement = {
}

%node NewContinueStatement NewStatement = {
}

%node NewBlockStatement NewStatement = {
    %nocreate NewStatementList *newListStatements;
}

/*Aqui termina el arbol decorado*/
AddStatement(BlockStatement)
{
    if(listStatements == 0)
      listStatements = new StatementList();
      
    listStatements->push_back(stm);
}

ToString(MethodCallExpression)
{
    ostringstream out;

    out << this->id << "(" << ListToString(parameters, ", ", false) << ")";

    return out.str();
}
ToString(AddExpression)
{
    ostringstream out;
    out << this->firstExpression->ToString() << "+" << this->secondExpression->ToString();
    return out.str();
}
ToString(SubExpression)
{
    ostringstream out;
    out << this->firstExpression->ToString() << "-" << this->secondExpression->ToString();
    return out.str();
}
ToString(MultExpression)
{
    ostringstream out;
    out << this->firstExpression->ToString() << "*" << this->secondExpression->ToString();
    return out.str();
}
ToString(DivExpression)
{
    ostringstream out;
    out << this->firstExpression->ToString() << "/" << this->secondExpression->ToString();
    return out.str();
}
ToString(LessThanExpression)
{
    ostringstream out;
    out << this->firstExpression->ToString() << "<" << this->secondExpression->ToString();
    return out.str();
}
ToString(LessThanEqualExpression)
{
    ostringstream out;
    out << this->firstExpression->ToString() << "<=" << this->secondExpression->ToString();
    return out.str();
}
ToString(BigerThanExpression)
{
    ostringstream out;
    out << this->firstExpression->ToString() << ">" << this->secondExpression->ToString();
    return out.str();
}
ToString(BigerThanEqualExpression)
{
    ostringstream out;
    out << this->firstExpression->ToString() << ">=" << this->secondExpression->ToString();
    return out.str();
}
ToString(EqualExpression)
{
    ostringstream out;
    out << this->firstExpression->ToString() << "==" << this->secondExpression->ToString();
    return out.str();
}
ToString(NotEqualExpression)
{
    ostringstream out;
    out << this->firstExpression->ToString() << "!=" << this->secondExpression->ToString();
    return out.str();
}
ToString(ShiftRightExpression)
{
    ostringstream out;
    out << this->firstExpression->ToString() << ">>" << this->secondExpression->ToString();
    return out.str();
}
ToString(ShiftLeftExpression)
{
    ostringstream out;
    out << this->firstExpression->ToString() << "<<" << this->secondExpression->ToString();
    return out.str();
}
ToString(RotExpression)
{
    ostringstream out;
    out << this->firstExpression->ToString() << "rot" << this->secondExpression->ToString();
    return out.str();
}
ToString(NotExpression)
{
    ostringstream out;
    out <<  "!" << this->firstExpression->ToString();
    return out.str();
}
ToString(AndExpression)
{
    ostringstream out;
    out << this->firstExpression->ToString() << "&&" << this->secondExpression->ToString();
    return out.str();
}
ToString(OrExpression)
{
    ostringstream out;
    out << this->firstExpression->ToString() << "||" << this->secondExpression->ToString();
    return out.str();
}
ToString(ModExpression)
{
    ostringstream out;
    out << this->firstExpression->ToString() << "%" << this->secondExpression->ToString();
    return out.str();
}
ToString(ConstantIntExpression)
{
    ostringstream out;
    out << this->constant;
    return out.str();
}

ToString(ConstantBoolExpression)
{
    ostringstream out;
    out << this->constant;
    return out.str();
}

ToString(ConstantStringExpression)
{
    ostringstream out;
    out << this->constant;
    return out.str();
}

ToString(ConstantCharExpression)
{
    ostringstream out;
    out << this->constant;
    return out.str();
}

ToString(LValueExpression)
{
    ostringstream out;

    out << this->id;

    if (expr != 0)
      out << "[" << expr->ToString() << "]";

    return out.str();
}

ToString(ParameterDef)
{
    ostringstream out;    
    out << TypeToString(parameterType) << " " << id; 
    return out.str();
}

ToString(MethodDef)
{
    ostringstream out;
    out << TypeToString(returnType) << " " << id << "(";
    if (parameters != 0)
      out << ListToString(parameters, ",", false);
    out << ")" << endl;
    out << block->ToString();
    return out.str();
}

ToString(VariableDef)
{
    ostringstream out;
    out << TypeToString(variable_type) << " " << id;
    if(isArrayDef){
      out << "[" << array_dimension << "]";
    }else if(initial_value != 0){
      out << "=" << initial_value->ToString();
    }
    out << ";";
    return out.str();
}

ToString(ReadStatement)
{
    ostringstream out;
    out << "read ";
    if (listExpression != 0)
      out << ListToString(listExpression, ",", false);
    return out.str();
}

ToString(PrintStatement)
{
    ostringstream out;
    out << "print ";
    if (listExpression != 0)
      out << ListToString(listExpression, ",", false);
    out << ";";
    return out.str();
}

ToString(IfStatement)
{
    ostringstream out;
    out << "if (" << condition->ToString() << ")" << endl;
    out << statementTrue->ToString() << endl;

    if (statementFalse != 0) {
		  out << "else" << endl;
		  out << statementFalse->ToString() << endl;
    }

    return out.str();
}

ToString(WhileStatement)
{
    ostringstream out;
    out << "while (" << condition->ToString() << ")" << endl;
    out << "{" << statementTrue->ToString() << endl << "}";
    return out.str();
}

ToString(ForStatement)
{
    ostringstream out;
    out << "for(";
    out << firstListAssign->ToString() << ";" << condition->ToString() << ";" << lastListAssign->ToString() <<")";
    out << statementTrue->ToString();

    return out.str();
}

ToString(AssignStatement)
{
    ostringstream out;
    out << "// Linea " << first_line << " Columna " << first_column << "\n"; 
    out << leftValue->ToString() << " = " << value->ToString() << ";";
    return out.str();
}

ToString(MethodCallStatement)
{
    return this->id + "(" + ListToString(parameters, ", ", false) + ");";
}

ToString(ReturnStatement)
{
    return "return " + returnExpression->ToString() + ";";
}

ToString(BreakStatement)
{
    return "break;";
}

ToString(ContinueStatement)
{
    return "continue;";
}

ToString(BlockStatement)
{
    ostringstream out;

    out << "{" << endl;

    if (listStatements != 0)
		  out << ListToString(listStatements, "\n", true);

    out << "}";

    return out.str();
}
ToString(ClassDef)
{
  ostringstream out;
  out << "class " << className << "{" << endl; 
  if (listVariable != 0)
      out << ListToString(listVariable, "\n", true);
  if (listMethod != 0)
      out << ListToString(listMethod, "\n", true);
  out << "}";
  return out.str(); 
}
/*************Validar Semantica ***************/

/* Validar semantica Expresiones */  
ValidarSemantica(ClassDef)
{
    contextos[0] = new Contexto();
    list<VariableDef*>::iterator it1;
    it1 = listVariable->begin();
    while(it1 != listVariable->end())
    {
        (*it1)->ValidarSemantica();
        it1++;
    }

    list<MethodDef*>::iterator it2;
    it2 = listMethod->begin();
    while(it2 != listMethod->end())
    {
        (*it2)->ValidarSemantica();
        it2++;
    }
    
    return new NewClassDef(className,NULL);
}

ValidarSemantica(AddExpression)
{
    NewExpression *first = (NewExpression*)firstExpression->ValidarSemantica();
    NewExpression *second = (NewExpression*)secondExpression->ValidarSemantica();

    if(first != NULL && second != NULL)
    {
        if((first->type == second->type) && (first->type == Int))
        {
            return new NewAddExpression(first,second);
        }
        ErrorSemantico("Error: Tipos Incompatibles");
        return NULL;
    }
    ErrorSemantico("Error: No se pudo Evaluar la Expresion");
    return NULL;
}

ValidarSemantica(SubExpression)
{
    NewExpression *first = (NewExpression*)firstExpression->ValidarSemantica();
    NewExpression *second = (NewExpression*)secondExpression->ValidarSemantica();

    if(first != NULL && second != NULL)
    {
        if((first->type == second->type) && first->type == Int)
        {
            return new NewSubExpression(first,second);
        }
        ErrorSemantico("Error: Tipos Incompatibles");
        return NULL;
    }
    ErrorSemantico("Error: No se pudo Evaluar la Expresion");
    return NULL;
}

ValidarSemantica(MultExpression)
{
    NewExpression *first = (NewExpression*)firstExpression->ValidarSemantica();
    NewExpression *second = (NewExpression*)secondExpression->ValidarSemantica();

    if(first != NULL && second != NULL)
    {
        if((first->type == second->type) && first->type == Int)
        {
            return new NewMultExpression(first,second);
        }
        ErrorSemantico("Error: Tipos Incompatibles");
        return NULL;
    }
    ErrorSemantico("Error: No se pudo Evaluar la Expresion");
    return NULL;
}

ValidarSemantica(DivExpression)
{
    NewExpression *first = (NewExpression*)firstExpression->ValidarSemantica();
    NewExpression *second = (NewExpression*)secondExpression->ValidarSemantica();

    if(first != NULL && second != NULL)
    {
        if((first->type == second->type) && first->type == Int)
        {
            return new NewDivExpression(first,second);
        }
        ErrorSemantico("Error: Tipos Incompatibles");
        return NULL;
    }
    ErrorSemantico("Error: No se pudo Evaluar la Expresion");
    return NULL;
}

ValidarSemantica(LessThanExpression)
{
    NewExpression *first = (NewExpression*)firstExpression->ValidarSemantica();
    NewExpression *second = (NewExpression*)secondExpression->ValidarSemantica();

    if(first != NULL && second != NULL)
    {
        if((first->type == second->type) && first->type == Int)
        {
            return new NewLessThanExpression(first,second);
        }
        ErrorSemantico("Error: Tipos Incompatibles");
        return NULL;
    }
    ErrorSemantico("Error: No se pudo Evaluar la Expresion");
    return NULL;
}

ValidarSemantica(BigerThanExpression)
{
    NewExpression *first = (NewExpression*)firstExpression->ValidarSemantica();
    NewExpression *second = (NewExpression*)secondExpression->ValidarSemantica();

    if(first != NULL && second != NULL)
    {
        if((first->type == second->type) && first->type == Int)
        {
            return new NewBigerThanExpression(first,second);
        }
        ErrorSemantico("Error: Tipos Incompatibles");
        return NULL;
    }
    ErrorSemantico("Error: No se pudo Evaluar la Expresion");
    return NULL;
}

ValidarSemantica(LessThanEqualExpression)
{
    NewExpression *first = (NewExpression*)firstExpression->ValidarSemantica();
    NewExpression *second = (NewExpression*)secondExpression->ValidarSemantica();

    if(first != NULL && second != NULL)
    {
        if((first->type == second->type) && first->type == Int)
        {
            return new NewLessThanEqualExpression(first,second);
        }
        ErrorSemantico("Error: Tipos Incompatibles");
        return NULL;
    }
    ErrorSemantico("Error: No se pudo Evaluar la Expresion");
    return NULL;
}

ValidarSemantica(BigerThanEqualExpression)
{
    NewExpression *first = (NewExpression*)firstExpression->ValidarSemantica();
    NewExpression *second = (NewExpression*)secondExpression->ValidarSemantica();

    if(first != NULL && second != NULL)
    {
        if((first->type == second->type) && first->type == Int)
        {
            return new NewBigerThanEqualExpression(first,second);
        }
        ErrorSemantico("Error: Tipos Incompatibles");
        return NULL;
    }
    ErrorSemantico("Error: No se pudo Evaluar la Expresion");
    return NULL;
}

ValidarSemantica(EqualExpression)
{
    NewExpression *first = (NewExpression*)firstExpression->ValidarSemantica();
    NewExpression *second = (NewExpression*)secondExpression->ValidarSemantica();

    if(first != NULL && second != NULL)
    {
        if((first->type == second->type) && first->type == Int)
        {
            return new NewEqualExpression(first,second);
        }
        ErrorSemantico("Error: Tipos Incompatibles");
        return NULL;
    }
    ErrorSemantico("Error: No se pudo Evaluar la Expresion");
    return NULL;
}

ValidarSemantica(NotEqualExpression)
{
    NewExpression *first = (NewExpression*)firstExpression->ValidarSemantica();
    NewExpression *second = (NewExpression*)secondExpression->ValidarSemantica();

    if(first != NULL && second != NULL)
    {
        if((first->type == second->type) && first->type == Int)
        {
            return new NewNotEqualExpression(first,second);
        }
        ErrorSemantico("Error: Tipos Incompatibles");
        return NULL;
    }
    ErrorSemantico("Error: No se pudo Evaluar la Expresion");
    return NULL;
}

ValidarSemantica(ShiftLeftExpression)
{
    NewExpression *first = (NewExpression*)firstExpression->ValidarSemantica();
    NewExpression *second = (NewExpression*)secondExpression->ValidarSemantica();

    if(first != NULL && second != NULL)
    {
        if((first->type == second->type) && first->type == Int)
        {
            return new NewShiftLeftExpression(first,second);
        }
        ErrorSemantico("Error: Tipos Incompatibles");
        return NULL;
    }
    ErrorSemantico("Error: No se pudo Evaluar la Expresion");
    return NULL;
}

ValidarSemantica(ShiftRightExpression)
{
    NewExpression *first = (NewExpression*)firstExpression->ValidarSemantica();
    NewExpression *second = (NewExpression*)secondExpression->ValidarSemantica();

    if(first != NULL && second != NULL)
    {
        if((first->type == second->type) && first->type == Int)
        {
            return new NewShiftRightExpression(first,second);
        }
        ErrorSemantico("Error: Tipos Incompatibles");
        return NULL;
    }
    ErrorSemantico("Error: No se pudo Evaluar la Expresion");
    return NULL;
}

ValidarSemantica(RotExpression)
{
    NewExpression *first = (NewExpression*)firstExpression->ValidarSemantica();
    NewExpression *second = (NewExpression*)secondExpression->ValidarSemantica();

    if(first != NULL && second != NULL)
    {
        if((first->type == second->type) && first->type == Int)
        {
            return new NewRotExpression(first,second);
        }
        ErrorSemantico("Error: Tipos Incompatibles");
        return NULL;
    }
    ErrorSemantico("Error: No se pudo Evaluar la Expresion");
    return NULL;
}

ValidarSemantica(OrExpression)
{
    NewExpression *first = (NewExpression*)firstExpression->ValidarSemantica();
    NewExpression *second = (NewExpression*)secondExpression->ValidarSemantica();

    if(first != NULL && second != NULL)
    {
        if((first->type == second->type) && first->type == Int)
        {
            return new NewOrExpression(first,second);
        }
        ErrorSemantico("Error: Tipos Incompatibles");
        return NULL;
    }
    ErrorSemantico("Error: No se pudo Evaluar la Expresion");
    return NULL;
}

ValidarSemantica(AndExpression)
{
    NewExpression *first = (NewExpression*)firstExpression->ValidarSemantica();
    NewExpression *second = (NewExpression*)secondExpression->ValidarSemantica();

    if(first != NULL && second != NULL)
    {
        if((first->type == second->type) && first->type == Int)
        {
            return new NewAndExpression(first,second);
        }
        ErrorSemantico("Error: Tipos Incompatibles");
        return NULL;
    }
    ErrorSemantico("Error: No se pudo Evaluar la Expresion");
    return NULL;
}

ValidarSemantica(ModExpression)
{
    NewExpression *first = (NewExpression*)firstExpression->ValidarSemantica();
    NewExpression *second = (NewExpression*)secondExpression->ValidarSemantica();

    if(first != NULL && second != NULL)
    {
        if((first->type == second->type) && first->type == Int)
        {
            return new NewModExpression(first,second);
        }
        ErrorSemantico("Error: Tipos Incompatibles");
        return NULL;
    }
    ErrorSemantico("Error: No se pudo Evaluar la Expresion");
    return NULL;
}

ValidarSemantica(NotExpression)
{
    NewExpression *first = (NewExpression*)firstExpression->ValidarSemantica();
    
    if(first != NULL )
    {
        if(first->type == Boolean)
        {
            return new NewNotExpression(first);
        }
        ErrorSemantico("Error: Tipo Incompatibles");
        return NULL;
    }
    ErrorSemantico("Error: No se pudo Evaluar la Expresion");
    return NULL;
}

ValidarSemantica(ParameterDef)
{
    return new NewParameterDef(id,parameterType);
}

ValidarSemantica(MethodCallExpression)
{
    list<NewExpression*> *newListExpression = new list<NewExpression*>();
    list<Expression*>::iterator it;
    it = parameters->begin();
    while(it != parameters->end())
    {
        NewExpression * newExpr = (NewExpression*)(*it)->ValidarSemantica();
        newListExpression->push_back(newExpr);
        it++;
    }
    return new NewMethodCallExpression(id,newListExpression);
}

ValidarSemantica(LValueExpression)
{
    NewExpression *newExpr = (NewExpression*)expr->ValidarSemantica();
    if(newExpr == NULL)
    {
        string msj = "Error en valor asignado";
        ErrorSemantico(msj);
        return NULL;
    } 
    else
    {
        if(newExpr->type != Int && newExpr->type != Boolean)
        {
            string msj = "Valor no asignable";
            ErrorSemantico(msj);
            return  NULL;
        }
    }
    return  NULL;
}

ValidarSemantica(ConstantIntExpression)
{
    return new NewConstantIntExpression(constant);
}

ValidarSemantica(ConstantCharExpression)
{
    return new NewConstantCharExpression(constant);
}

ValidarSemantica(ConstantStringExpression)
{
    return new NewConstantStringExpression(constant);
}

ValidarSemantica(ConstantBoolExpression)
{
    return new NewConstantBoolExpression(constant);
}

/* Validar semantica Statements */

ValidarSemantica(IfStatement)
{
    NewExpression *newCondition = (NewExpression*)condition->ValidarSemantica();
    if(newCondition == NULL)
        return NULL;
    if(newCondition->type == Boolean)
    {
        ErrorSemantico("Error: Condicion if debe se bool");
        return NULL;
    }
    NewStatement *newTrueBlock = (NewStatement*)statementTrue->ValidarSemantica();
    NewStatement *newFalseBlock;
    if(newTrueBlock == NULL)
        return NULL;
    if(statementFalse != NULL)
    {
        newFalseBlock = (NewStatement*)statementFalse->ValidarSemantica();
        if(newFalseBlock == NULL)
            return NULL;
    }
    return new NewIfStatement(newCondition,newTrueBlock,newFalseBlock);
}

ValidarSemantica(WhileStatement)
{
    NewExpression *newCondition = (NewExpression*)condition->ValidarSemantica();
    if(newCondition == NULL)
        return NULL;
    if(newCondition->type == Boolean)
    {
        ErrorSemantico("Error: Condicion if debe se bool");
        return NULL;                       
    }

    NewStatement *newStatementTrue = (NewStatement*)statementTrue->ValidarSemantica();
    if(newStatementTrue == NULL)
        return NULL;

    return new NewWhileStatement(newCondition,newStatementTrue);
}

ValidarSemantica(ForStatement)
{
    NewStatement *newFirstListAssign = (NewStatement*)firstListAssign->ValidarSemantica();
    if(newFirstListAssign == NULL)
        return NULL;

    NewExpression *newCondition = (NewExpression*)condition->ValidarSemantica();
    if(newCondition == NULL)
        return NULL;

    if(newCondition->type != Boolean)
        return NULL;

    NewStatement *newLastListAssign = (NewStatement*)lastListAssign->ValidarSemantica();
    if(newLastListAssign == NULL)
        return NULL;

    NewStatement *newStatementTrue = (NewStatement*)statementTrue->ValidarSemantica();
    if(newStatementTrue == NULL)
        return NULL;

    return new NewForStatement(newFirstListAssign,newCondition,newLastListAssign,newStatementTrue);
}

ValidarSemantica(ReturnStatement)
{
    NewExpression *newReturnExpression = (NewExpression*)returnExpression->ValidarSemantica();
    if(newReturnExpression != NULL)
        return NULL;
    return new NewReturnStatement(newReturnExpression);
}

ValidarSemantica(BlockStatement)
{
    list<NewStatement*> *newListStatement = new list<NewStatement*>();
    if(listStatements == NULL)
        return NULL;

    list<Statement*>::iterator it;
    it = listStatements->begin();
    while(it != listStatements->end()) {
        Statement *stmTemp = *it;
        NewStatement *newStm ;
        if(dynamic_cast<BlockStatement*>(stmTemp)!= NULL)
        {
          currentContexto += 1; 
          newStm = (NewStatement*)stmTemp->ValidarSemantica();
          currentContexto -= 1;
        }
        else
        {
          newStm = (NewStatement*)stmTemp->ValidarSemantica();
        }
        if(newStm == NULL)
            return NULL;
        newListStatement->push_back(newStm);
        it++;
    }
    NewBlockStatement *newblock = new NewBlockStatement(); 
    newblock->newListStatements = newListStatement;
    return newblock;
}

ValidarSemantica(ReadStatement)
{
    list<NewExpression*> *newListExpression = new list<NewExpression*>();
    if(listExpression == NULL)
        return NULL;

    list<Expression*>::iterator it;
    it = listExpression->begin();
    while(it != listExpression->end()) {
        Expression *exprTemp = *it;
        NewExpression *newExpr = (NewExpression*)exprTemp->ValidarSemantica();
        if(newExpr == NULL)
            return NULL;
        newListExpression->push_back(newExpr);
        it++;
    }
    return new NewReadStatement(newListExpression);
}

ValidarSemantica(PrintStatement)
{
    list<NewExpression*> *newListExpression = new list<NewExpression*>();
    if(listExpression == NULL)
        return NULL;

    list<Expression*>::iterator it = listExpression->begin();
    while(it != listExpression->end()) {
        Expression *exprTemp = *it;
        NewExpression *newExpr = (NewExpression*)exprTemp->ValidarSemantica();
        if(newExpr == NULL)
            return NULL;
        newListExpression->push_back(newExpr);
        it++;
    }
    return new NewPrintStatement(newListExpression);
}

ValidarSemantica(AssignStatement)
{
    NewExpression *newLeftValue = (NewExpression*)leftValue->ValidarSemantica();
    if(newLeftValue == NULL)
        return NULL;

    NewExpression *newValue = (NewExpression*)value->ValidarSemantica();
    if(newValue == NULL)
        return NULL;

    return new NewAssignStatement(newLeftValue,newValue);
}

ValidarSemantica(MethodCallStatement)
{
  if(methodDeclared[id]!= NULL)
  {
    string str = "Metodo no declarado";
    ErrorSemantico(str);
    return NULL;
  }

  list<NewExpression*> *newListExpression = new list<NewExpression*>();

  list<Expression*>::iterator it;
  it = parameters->begin();
  while(it != parameters->end()) {
    NewExpression * newExpr = (NewExpression*)((*it)->ValidarSemantica());
    if(newExpr == NULL)
    {
      string str = "Error";
      ErrorSemantico(str);
      return NULL;
    }
    newListExpression->push_back(newExpr);
    it++;  
  }

  return new NewMethodCallStatement(id,newListExpression);
}

ValidarSemantica(MethodDef)
{
    cout<<"metodo"<<endl;
  Contexto *contestoActual = contextos[currentContexto];
  currentContexto += 1;

  Contexto *contextoNuevo = new Contexto();
  contextoNuevo->currentLevel = 0;
  contextoNuevo->currentOffset = 1;

  list<ParameterDef *>::iterator it;
  it = parameters->begin();
  while(it != parameters->end())
  {
    cout<<"parametro"<<endl;
    NewParameterDef *param = (NewParameterDef*)(*it)->ValidarSemantica();
    string str = param->newId;
    Type tipo = param->newParameterType;
    Variable *var = new Variable(contextoNuevo->currentOffset,contextoNuevo->currentLevel,0,false,0,tipo);
    if(contextoNuevo->contextoMap[str] != NULL){
      string str = "Parametros repetidos";
      ErrorSemantico(str);
      return NULL;
    }else{
      contextoNuevo->contextoMap[str] = var;
      contextoNuevo->currentOffset += 1;
    }
    it++;
  }
  cout<<"fin funcion"<<endl;
  contextos[currentContexto] = contextoNuevo;
  contextoNuevo->contextoAnterior = contestoActual;
  //NewBlockStatement *newBlockStatement = (NewBlockStatement*)block->ValidarSemantica();
  NewBlockStatement *newBlockStatement = NULL;
  if(methodDeclared[id] != NULL)
  {
    string str = "Metodo ya definido";
    ErrorSemantico(str);
    return NULL;
  }
  Procedimiento *p = new Procedimiento(id,newBlockStatement);
  methodDeclared[id] = p;
  return NULL;
}

ValidarSemantica(VariableDef)
{
    Variable *var = contextos[currentContexto]->contextoMap[id];
    if(var != NULL){
      string error = "Variable ya definida";
      ErrorSemantico(error);
      return NULL;
    }
    contextos[currentContexto]->currentOffset+=1;
    int offset = contextos[currentContexto]->currentOffset;
    int level = contextos[currentContexto]->currentLevel;
    Variable *newVariable;
    if(isArrayDef)
    {
       // NewExpression* expr = (NewExpression*)initial_value->ValidarSemantica();   
        newVariable = new Variable(offset,level,0,true,array_dimension,variable_type);
    }
    else
    {
       // NewExpression * expr = (NewExpression*)initial_value->ValidarSemantica();
        newVariable = new Variable(offset,level,0,false,0,variable_type);
    }
    contextos[currentContexto]->contextoMap[id] = newVariable;
    return NULL;
}

ValidarSemantica(BreakStatement)
{
    return new NewBreakStatement();
}

ValidarSemantica(ContinueStatement)
{
    return new NewContinueStatement();
}

/**************Generacion de Codigo Expresiones **************/
/*    string className;
    NewBlockStatement *newBlockStatement;
*/
GenerarCodigo(NewClassDef)
{
  ostringstream nuevo;
  nuevo << "main :";
  map<string,Procedimiento *>::iterator it;
  it = methodDeclared.begin();
  while(it != methodDeclared.end())
  {
    Procedimiento *p = it->second;
    nuevo<<p->id <<" :";
    nuevo<<"codigo";
    it++;
  }
  


  return nuevo.str();   
}

GenerarCodigo(NewAddExpression)
{
    string L = newfirstExpression->GenerarCodigo();
    string R = newSecondExpression->GenerarCodigo();

    ostringstream nuevo ;
    nuevo << L + R;
    FreeRegister(newfirstExpression->place);
    FreeRegister(newSecondExpression->place);
    string registro = getFreeRegister();
    nuevo << "add " << registro <<","<<newfirstExpression->place<<","<<newSecondExpression->place;
    place = registro;

    return nuevo.str();
}

GenerarCodigo(NewSubExpression)
{
    string L = newfirstExpression->GenerarCodigo();
    string R = newSecondExpression->GenerarCodigo();

    ostringstream nuevo;
    nuevo << L + R;
    FreeRegister(newfirstExpression->place);
    FreeRegister(newSecondExpression->place);
    string registro = getFreeRegister();
    nuevo << "sub "<< registro <<","<<newfirstExpression->place<<","<<newSecondExpression->place;
    place = registro;

    return nuevo.str();
}

GenerarCodigo(NewMultExpression) 
{
    string L = newfirstExpression->GenerarCodigo();
    string R = newSecondExpression->GenerarCodigo();

    ostringstream nuevo;
    nuevo << L + R;
    FreeRegister(newfirstExpression->place);
    FreeRegister(newSecondExpression->place);
    nuevo << "mult "<< newfirstExpression->place<<","<<newSecondExpression->place;
    place = newfirstExpression->place;

    return nuevo.str();
}

GenerarCodigo(NewDivExpression)
{
    string L = newfirstExpression->GenerarCodigo();
    string R = newSecondExpression->GenerarCodigo();

    ostringstream nuevo;
    nuevo << L + R;
    FreeRegister(newfirstExpression->place);
    FreeRegister(newSecondExpression->place);
    nuevo << "div "<< newfirstExpression->place<<","<<newSecondExpression->place;
    place = newfirstExpression->place;

    return nuevo.str();
}

GenerarCodigo(NewLessThanExpression)
{
    string L = newfirstExpression->GenerarCodigo();
    string R = newSecondExpression->GenerarCodigo();

    ostringstream nuevo;
    nuevo << L + R;
    FreeRegister(newfirstExpression->place);
    FreeRegister(newSecondExpression->place);
    string label = "stackCurrentLabel.pop_back()";    
    nuevo << "blt "<< newfirstExpression->place<<","<<newSecondExpression->place <<","<< label;

    place = "";

    return nuevo.str();   
}

GenerarCodigo(NewLessThanEqualExpression)
{
    string L = newfirstExpression->GenerarCodigo();
    string R = newSecondExpression->GenerarCodigo();

    ostringstream nuevo;
    nuevo << L + R;
    FreeRegister(newfirstExpression->place);
    FreeRegister(newSecondExpression->place);
    string label = "stackCurrentLabel.pop_back()";
    nuevo << "ble "<< newfirstExpression->place<<","<<newSecondExpression->place <<","<< label;
    place = "";

    return nuevo.str();   
}

GenerarCodigo(NewBigerThanExpression)
{
    string L = newfirstExpression->GenerarCodigo();
    string R = newSecondExpression->GenerarCodigo();

    ostringstream nuevo;
    nuevo << L + R;
    FreeRegister(newfirstExpression->place);
    FreeRegister(newSecondExpression->place);
    string label = "stackCurrentLabel.pop_back()";
    nuevo << "bgt "<< newfirstExpression->place<<","<<newSecondExpression->place <<","<< label;
    place = "";

    return nuevo.str();   
}

GenerarCodigo(NewBigerThanEqualExpression)
{
    string L = newfirstExpression->GenerarCodigo();
    string R = newSecondExpression->GenerarCodigo();

    ostringstream nuevo;
    nuevo << L + R;
    FreeRegister(newfirstExpression->place);
    FreeRegister(newSecondExpression->place);
    string label =" stackCurrentLabel.pop_back()";
    nuevo << "bge "<< newfirstExpression->place<<","<<newSecondExpression->place <<","<< label;
    place = "";

    return nuevo.str();   
}

GenerarCodigo(NewEqualExpression)
{
    string L = newfirstExpression->GenerarCodigo();
    string R = newSecondExpression->GenerarCodigo();

    ostringstream nuevo;
    nuevo << L + R;
    FreeRegister(newfirstExpression->place);
    FreeRegister(newSecondExpression->place);
    string label = "stackCurrentLabel.pop_back()";
    nuevo << "beq "<< newfirstExpression->place<<","<<newSecondExpression->place <<","<< label;
    place = "";

    return nuevo.str();  
}

GenerarCodigo(NewNotEqualExpression)
{
    string L = newfirstExpression->GenerarCodigo();
    string R = newSecondExpression->GenerarCodigo();

    ostringstream nuevo ;
    nuevo << L + R;
    FreeRegister(newfirstExpression->place);
    FreeRegister(newSecondExpression->place);
    string label = "stackCurrentLabel.pop_back()";
    nuevo << "bne "<< newfirstExpression->place<<","<<newSecondExpression->place<<","<<label;
    place = "";

    return nuevo.str();
}

GenerarCodigo(NewShiftRightExpression)
{
    string L = newfirstExpression->GenerarCodigo();
    string R = newSecondExpression->GenerarCodigo();

    ostringstream nuevo;
    nuevo << L + R;
    FreeRegister(newfirstExpression->place);
    FreeRegister(newSecondExpression->place);
    string registro = getFreeRegister();
    nuevo << "srl "<< registro << newfirstExpression->place<<","<<newSecondExpression->place;
    place = registro;

    return nuevo.str();
}

GenerarCodigo(NewShiftLeftExpression)
{
    string L = newfirstExpression->GenerarCodigo();
    string R = newSecondExpression->GenerarCodigo();

    ostringstream nuevo;
    nuevo << L + R;
    FreeRegister(newfirstExpression->place);
    FreeRegister(newSecondExpression->place);
    string registro = getFreeRegister();
    nuevo << "sll "<< registro << newfirstExpression->place<<","<<newSecondExpression->place;
    place = registro;

    return nuevo.str();
}

GenerarCodigo(NewRotExpression)
{
    string L = newfirstExpression->GenerarCodigo();
    string R = newSecondExpression->GenerarCodigo();

    ostringstream nuevo;
    nuevo << L + R;
    FreeRegister(newfirstExpression->place);
    FreeRegister(newSecondExpression->place);
    string registro = getFreeRegister();
    nuevo << "rot "<< registro << newfirstExpression->place<<","<<newSecondExpression->place;
    place = registro;

    return nuevo.str();
}

GenerarCodigo(NewOrExpression)
{
    string L = newfirstExpression->GenerarCodigo();
    string R = newSecondExpression->GenerarCodigo();

    ostringstream nuevo;
    nuevo << L + R;
    FreeRegister(newfirstExpression->place);
    FreeRegister(newSecondExpression->place);
    string registro = getFreeRegister();
    nuevo << "or "<< registro << newfirstExpression->place<<","<<newSecondExpression->place;
    place = registro;

    return nuevo.str();
}

GenerarCodigo(NewAndExpression)
{
    string L = newfirstExpression->GenerarCodigo();
    string R = newSecondExpression->GenerarCodigo();

    ostringstream nuevo;
    nuevo << L + R;
    FreeRegister(newfirstExpression->place);
    FreeRegister(newSecondExpression->place);
    string registro = getFreeRegister();
    nuevo << "and "<< registro << newfirstExpression->place<<","<<newSecondExpression->place;
    place = registro;

    return nuevo.str();
}

//Pendiente
GenerarCodigo(NewNotExpression)
{
    string L = newfirstExpression->GenerarCodigo();

    ostringstream nuevo;
    nuevo << L ;
    FreeRegister(newfirstExpression->place);
    string registro = getFreeRegister();
    nuevo << " "<< registro << newfirstExpression->place;;
    place = registro;

    return nuevo.str();
}

//Pendiente
GenerarCodigo(NewModExpression)
{
    string L = newfirstExpression->GenerarCodigo();
    string R = newSecondExpression->GenerarCodigo();

    ostringstream nuevo;
    nuevo << L + R;
    FreeRegister(newfirstExpression->place);
    FreeRegister(newSecondExpression->place);
    string registro = getFreeRegister();
    nuevo << " "<< registro << newfirstExpression->place<<","<<newSecondExpression->place;
    place = registro;

    return nuevo.str();
}

/************** Generacion de Codigo Sentencias **************/

GenerarCodigo(NewIfStatement)
{
    string labelIf = getLabel("if");
    string labelElse = getLabel("else");
    string labelEndIf = getLabel("endIf");
    
    //no se si lo de arriba o esto
    stackCurrentLabel.push_back(labelIf);

    string condition = newCondition->GenerarCodigo();
    ostringstream nuevo;
    nuevo << condition;
    
    if(newStatementFalse != NULL)
        nuevo << "j " << labelElse;
    else
        nuevo << "j " << labelEndIf;

    nuevo << labelIf << " :";
    nuevo << newStatementTrue->GenerarCodigo();

    if(newStatementFalse != NULL)
    {
        nuevo << labelElse << " :";
        nuevo << newStatementFalse->GenerarCodigo();
    }

    nuevo << labelEndIf << " :";
    return nuevo.str();
}

GenerarCodigo(NewWhileStatement)
{
    string labelStartWhile = getLabel("startWhile");
    string labelWhile = getLabel("while");
    string labelEndWhile = getLabel("endWhile");

    stackCurrentLabel.push_back(labelWhile);
    string condition = newCondition->GenerarCodigo();
    
    ostringstream nuevo;
    nuevo << labelStartWhile << " :";
    nuevo << condition;
    nuevo << "j " << labelEndWhile;

    nuevo << labelWhile << " :";
    nuevo << newStatementTrue->GenerarCodigo();
    nuevo << "j " << labelStartWhile; 

    nuevo << labelEndWhile << " :";
    return nuevo.str();
}

GenerarCodigo(NewForStatement)
{
    string labelStartFor = getLabel("startFor");
    string labelfor = getLabel("for");
    string labelEndfor = getLabel("endfor");

    stackCurrentLabel.push_back(labelfor);

    string firstListAssign = newFirstListAssign->GenerarCodigo();
    string lastListAssign = newLastListAssign->GenerarCodigo();

    ostringstream nuevo;
    nuevo << firstListAssign;
    nuevo << lastListAssign;
    string condition = newCondition->GenerarCodigo();

    nuevo << labelStartFor << " :";
    nuevo << condition;
    nuevo << "j " << labelEndfor;

    nuevo << labelfor << " :";
    nuevo << newStatementTrue->GenerarCodigo();
    nuevo << "j " << labelStartFor; 

    nuevo << labelEndfor << " :";
    return nuevo.str();
}

GenerarCodigo(NewAssignStatement)
{

}

GenerarCodigo(NewMethodCallStatement)
{
    ostringstream nuevo ;
    list<NewExpression *>::iterator it;
    it = newParameters->begin();
    int parameterCount = newParameters->size();
    nuevo << "addi " << "$sp" << (-1 * parameterCount);
    int parameterPosition = 0;
    while(it != newParameters->end())
    {   
        nuevo << (*it)->GenerarCodigo();
        nuevo << "sw " << "("<< (parameterPosition * 4)<<")$sp"<< "," ;
        it++;
    }

    nuevo << "jal " + id;
    return nuevo.str();
}

GenerarCodigo(NewReturnStatement)
{
    ostringstream nuevo;
    nuevo << newReturnExpression->GenerarCodigo();
    nuevo << "move "<< "$v0" <<" , "<< newReturnExpression->place; 
    nuevo << "jr " << "$ra";
    return nuevo.str();
}

GenerarCodigo(NewPrintStatement)
{
    /*ostringstream nuevo;
    list<NewExpression *>::iterator it;
    it = newListExpression->begin();
    while(it != newListExpression->end())
    { 
        NewExpression *expr = *it;
        nuevo << expr->GenerarCodigo();
        if(expr->type == Type.Int)
        {
            nuevo << "li " << "$v0" <<","<< "1";
            nuevo << "move " << "$a0" << expr->place;
            nuevo << "syscall";
        }
        else if(expr->type == Type.String)
        {
            nuevo << "li " << "$v0" <<","<< "4";
            nuevo << "move " << "$a0" <<","<< expr->place;
            nuevo << "syscall";
        }
    }*/

    //return nuevo.str();
    return "falta";
}

GenerarCodigo(NewReadStatement)
{
    ostringstream nuevo;
    list<NewExpression *>::iterator it;
    it = newListExpression->begin();
    while(it != newListExpression->end())
    { 
        NewExpression *expr = (*it);
        nuevo << expr->GenerarCodigo();
        it++;

    }

    return nuevo.str();
}

GenerarCodigo(NewConstantIntExpression){return "falta";}

GenerarCodigo(NewConstantBoolExpression){return "falta";}

GenerarCodigo(NewConstantStringExpression){return "falta";}

GenerarCodigo(NewConstantCharExpression){return "falta";}

GenerarCodigo(NewParameterDef){return "falta";}

GenerarCodigo(NewLValueExpression){return "falta";}

GenerarCodigo(NewMethodCallExpression){return "falta";}

GenerarCodigo(NewBreakStatement){return "falta";}

GenerarCodigo(NewContinueStatement){return "falta";}

GenerarCodigo(NewBlockStatement){return "falta";}